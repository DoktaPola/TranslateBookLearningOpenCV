## (П]|(РС)|(РП) Базовые манипуляции над гистограммами

Теперь, имея структуру Histogram, можем переходить к разбору некоторых интересных вещей. Для начала необходимо расмотреть основы основ, которые будут использоваться снова и снова. А затем уже можно будет перейти к более сложным функциям, которые можно будет задействовать при выполнении более сложных задач.

При работе с гистограммами, как правило, необходимо просто накапливать информацию в различных контейнерах. При этом, зачастую желательно, чтобы гистограмма была нормализована, т.е. когда каждый контейнер представляли долю от общего числа событий:

```cpp
	cvNormalizeHist( CvHistogram* hist, double factor );
```

Аргумент *hist* - это гистограмма, а *factor* - число на которое необходимо нормализовать гистограмму (обычно он равен 1). Как можно было заметить, аргумент *factor* имеет тип double, хотя внутри функции *CvHistogram()* он всегда float - это ещё одно доказательство того, что OpenCV постоянно развивается!

Следующая удобная функция - функция порогового преобразования:

```cpp
	cvThreshHist( CvHistogram* hist, double factor );
```

Аргумент *factor* - это поторговое значение. В результате порогового преобразования над гистограммой, все контейнеры, у которых стоимость ниже порогового значения, устанавливаются в 0. Если вспомнить функцию *cvThreshold()*, можно сказать, что функция порогового преобразования над гистограммами аналогична вызову функции порогового преобразования над изображениями с установленным значением аргумента *threshold_type* в *CV_THRESH_TOZERO*. К сожалению не существует функций обеспечивающих преобразования аналогичные другим функциям пороговых преобразований. Однако, на практике, *cvThreshHist()* вполне достаточно, т.к. при работе с реальными данными некоторые контейнеры содержат малое количество точек, которые в свою очередь еще являются шумами и должны быть, как правило, обнуляться.

*cvCopyHist()* - ещё одна удобная функция, которая копирует данные одной гистограммы в другую.

```cpp
	void cvCopyHist( const CvHistogram* src, CvHistogram** dst );
```

Эту функцию можно использовать двумя способами. Если конечная гистограмма ***dst** имеет тот же размер, что и исходная гистограмма, то все данные **src** будут скопированы в ***dst**. Другой способ использовать *cvCopyHist()* - установить ***dst** в NULL, в этом случае под ***dst** будет выделено столько памяти, сколько занимает **src**, с последующим копированием данных (эту функцию можно сравнить с аналогичной ей *cvCloneImage()*). Если при вызове *cvCopyHist()* ***dst = NULL**, то ***dst** будет задан указателем на вновь выделенную гистограмму только после того, как функция вернет значение.

Следующей удобной функцией является *cvGetMinMaxHistValue()*, которая возвращает максимальное и минимальное значения в гистограмме.

```cpp
	void cvGetMinMaxHistValue(
		 const CvHistogram* 	hist
		,float* 				min_value
		,float* 				max_value
		,int* 					min_idx = NULL
		,int* 					max_idx = NULL
	);
```

Аргумент *hist* - это гистограмма. Функция возвращает максимальное и минимальное значения в ***min_value** and ***max_value** соответственно. Если одно из значений (или оба) не нужны, тогда нужно установить соответствующий аргумент в NULL. Следующие два аргумента не обязательны: если они установлены в значения по умолчанию (NULL), то они не используются. Однако, если указатели ***int != NULL**, тогда эти аргументы будут содержать индексы минимального и максимального значений. Если гистограмма многомерная, то аргументы *min_idx* и *max_idx* (если они не NULL) должны указывать на массивы целых чисел размером равным размерности гистограммы. Если более чем один контейнер имеет одинаковое минимальное (или максимальное) значение, то будет возвращен наименьший индекс (в лексографическом порядке для многомерных гистограмм).

Зачастую, после сбора данных и формирования гистограммы используется функция *cvGetMinMaxHistValue()* для поиска минимального значения, с последующим поиском порога в районе этого минимума при помощи *cvThreshHist()* и окончательной нормализацией гистограммы при помощи *cvNormalizeHist()*.

Последней, но не менее значимой, удобной функцией является cvCalcHist(). Она автоматически вычисляет гистограмму по изображению:

```cpp
	void cvCalcHist(
		 IplImage** 	image
		,CvHistogram* 	hist
		,int 			accumulate = 0
		,const CvArr* 	mask = NULL
	);
```

 Аргумент *image* - это указатель на массив указателей на *IplImage*. Это позволяет обрабатывать несколько плоскостей изображения. В случае с многоканальными изображениями (например, HSV или RGB), перед вызовом *cvCalcHist()* необходимо разделить это изображение на плоскости при помощи *cvSplit()*. Правда это немного мучительно, однако, зачастую, требуется "пройтись" по многоканальному изображению, которое содержит различные отфильтрованные версии изображения - например, плоскость градиента или U- и V- плоскости YUV. Это может повлеч за собой бардак при попытке передачи изображений с различным числом каналов (а то, что кто-то в определенный момент времени захочет получить лишь часть изображения сомневаться не стоит!). Что бы избежать всей этой путаницы, передаваемые в *cvCalcHist()* изображения должны быть одноканальными. 