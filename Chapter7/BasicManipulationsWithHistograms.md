## (П]|(РС)|(РП) Базовые манипуляции над гистограммами

Теперь, имея структуру Histogram, можем переходить к разбору некоторых интересных вещей. Для начала необходимо расмотреть основы основ, которые будут использоваться снова и снова. А затем уже можно будет перейти к более сложным функциям, которые можно будет задействовать при выполнении более сложных задач.

При работе с гистограммами, как правило, необходимо просто накапливать информацию в различных контейнерах. При этом, зачастую желательно, чтобы гистограмма была нормализована, т.е. когда каждый контейнер представляли долю от общего числа событий:

```cpp
	cvNormalizeHist( CvHistogram* hist, double factor );
```

Аргумент *hist* - это гистограмма, а *factor* - число на которое необходимо нормализовать гистограмму (обычно он равен 1). Как можно было заметить, аргумент *factor* имеет тип double, хотя внутри функции *CvHistogram()* он всегда float - это ещё одно доказательство того, что OpenCV постоянно развивается!

Следующая удобная функция - функция порогового преобразования:

```cpp
	cvThreshHist( CvHistogram* hist, double factor );
```

Аргумент *factor* - это поторговое значение. В результате порогового преобразования над гистограммой, все контейнеры, у которых стоимость ниже порогового значения, устанавливаются в 0. Если вспомнить функцию *cvThreshold()*, можно сказать, что функция порогового преобразования над гистограммами аналогична вызову функции порогового преобразования над изображениями с установленным значением аргумента *threshold_type* в *CV_THRESH_TOZERO*. К сожалению не существует функций обеспечивающих преобразования аналогичные другим функциям пороговых преобразований. Однако, на практике, *cvThreshHist()* вполне достаточно, т.к. при работе с реальными данными некоторые контейнеры содержат малое количество точек, которые в свою очередь еще являются шумами и должны быть, как правило, обнуляться.

*cvCopyHist()* - ещё одна удобная функция, которая копирует данные одной гистограммы в другую.

```cpp
	void cvCopyHist( const CvHistogram* src, CvHistogram** dst );
```

Эту функцию можно использовать двумя способами. Если конечная гистограмма ***dst** имеет тот же размер, что и исходная гистограмма, то все данные **src** будут скопированы в ***dst**. Другой способ использовать *cvCopyHist()* - установить ***dst** в NULL, в этом случае под ***dst** будет выделено столько памяти, сколько занимает **src**, с последующим копированием данных (эту функцию можно сравнить с аналогичной ей *cvCloneImage()*). Если при вызове *cvCopyHist()* ***dst = NULL**, то ***dst** будет задан указателем на вновь выделенную гистограмму только после того, как функция вернет значение.

Следующей удобной функцией является *cvGetMinMaxHistValue()*, которая возвращает максимальное и минимальное значения в гистограмме.

```cpp
	void cvGetMinMaxHistValue(
		 const CvHistogram* 	hist
		,float* 				min_value
		,float* 				max_value
		,int* 					min_idx = NULL
		,int* 					max_idx = NULL
	);
```

Аргумент *hist* - это гистограмма. Функция возвращает максимальное и минимальное значения в ***min_value** and ***max_value** соответственно. Если одно из значений (или оба) не нужны, тогда нужно установить соответствующий аргумент в NULL. Следующие два аргумента не обязательны: если они установлены в значения по умолчанию (NULL), то они не используются. Однако, если указатели ***int != NULL**, тогда эти аргументы будут содержать индексы минимального и максимального значений. Если гистограмма многомерная, то аргументы *min_idx* и *max_idx* (если они не NULL) должны указывать на массивы целых чисел размером равным размерности гистограммы. Если более чем один контейнер имеет одинаковое минимальное (или максимальное) значение, то будет возвращен наименьший индекс (в лексографическом порядке для многомерных гистограмм).

Зачастую, после сбора данных и формирования гистограммы используется функция *cvGetMinMaxHistValue()* для поиска минимального значения, с последующим поиском порога в районе этого минимума при помощи *cvThreshHist()* и окончательной нормализацией гистограммы при помощи *cvNormalizeHist()*.

Последней, но не менее значимой, удобной функцией является cvCalcHist(). Она автоматически вычисляет гистограмму по изображению:

```cpp
	void cvCalcHist(
		 IplImage** 	image
		,CvHistogram* 	hist
		,int 			accumulate = 0
		,const CvArr* 	mask = NULL
	);
```

 Аргумент *image* - это указатель на массив указателей на *IplImage* (также возможно использование указателя на матрицу **CvMat***). Это позволяет обрабатывать несколько плоскостей изображения. В случае с многоканальными изображениями (например, HSV или RGB), перед вызовом *cvCalcHist()* необходимо разделить это изображение на плоскости при помощи *cvSplit()*. Правда это немного мучительно, однако, зачастую, требуется "пройтись" по многоканальному изображению, которое содержит различные отфильтрованные версии изображения - например, плоскость градиента или U- и V- плоскости YUV. Это может повлеч за собой бардак при попытке передачи изображений с различным числом каналов (а то, что кто-то в определенный момент времени захочет получить лишь часть изображения сомневаться не стоит!). Что бы избежать всей этой путаницы, передаваемые в *cvCalcHist()* изображения должны быть одноканальными. При заполнении гистограмм, контейнеры будут идентифицироваться как кортежи, образованные на основе этих многоканальных изображениях. Аргумент *hist* должен быть гистограммой соответствующего размера (т.е. размерности, равной числу плоскостей изображения передаваемых изображений). Последние два аргумента не обязательны. Если накопительный аргумент не нулевой, то он указывает на то, что гистограмма *hist* не должна быть очищена прежде чем изображение будет прочитано; стоит обратить внимание на то, что накопитель позволяет вызывать *cvCalcHist()* несколько раз во время циклического сбора данных. Последний аргумент *mask* обычно необязательная булевая маска; если *mask != NULL*, тогда пиксели, соответствующие ненулевым элементам в маске будут включены в гистограмму.

 ### Сравнение двух гистограмм

 Ещё одним незаменимым инструментом для работы с гистограммами, впервые введенный Swain и Ballard и обобщенный в дальнейшем Schiele и Crowley, является возможность сравнить две гистограммы в терминологии некоторых специфичных критериев подобия. В OpenCV для этого существует функция *cvCompareHist()*:

 ```cpp
	double cvCompareHist(
		 const CvHistogram* 	hist1
		,const CvHistogram* 	hist2
		,int 					method
	);
 ```

Первые два аргумента - это гистограммы для сравнения, которые должны быть одинакового размера. Третий аргумент задает дистанционную метрику. Доступны четыре варианта этой метрики.

**Корреляция (method = CV_COMP_CORREL)**

![Формула 7- не найдена](Images/Frml_7_.jpg)

где ![Формула 7- не найдена](Images/Frml_7_.jpg), а N равно числу контейнеров гистограммы. 

Для *корреляции* большая оценка представляет лучшее совпадение, чем меньшая. Идеальное совпадение 1, а максимальное несовпадение -1; значение 0 указывает на отсутствие корреляции (случайная ассоциация).

**Хи-квадрат (method = CV_COMP_CHISQR)**

![Формула 7- не найдена](Images/Frml_7_.jpg)

Для *хи-квадрата* (хи-квадрат был изобретён Karl Pearson, который основал область математической статистики) более низкая оценка означает лучшее совпадение, чем более высокая. Идеальное совпадение равно 0, а максимальное несовпадение не ограничено (зависит от размера гистограммы)

**Пересечение (method = CV_COMP_INTERSECT)**

![Формула 7- не найдена](Images/Frml_7_.jpg)

Для *пересечения гистограмм* высокая оценка указывает на хорошее совпадение, а низкая на плохое. Если обе гистограммы нормированы на 1, то идеальное совпадение это 1, а совершенное несовпадение - 0.

**Расстояние Bhattacharyya (method = CV_COMP_BHATTACHARYYA)**

![Формула 7- не найдена](Images/Frml_7_.jpg)

Для *соответствия Bhattacharyya* низкие показатели свидетельствуют о хорошем совпадении, а высокие о плохом. Идеальное совпадение это 0, а совершенное несовпадение 1. 

При помощи *CV_COMP_BHATTACHARYYA* осуществляется нормализация исходной гистограммы. В целом, однако, нормализация гистограмм должна происходить перед их сравнением, потому что такие понятия, как пересечение гистограмм имеют мало смысла без нормализации.

Простейший случай изображенный на рисунке 7-4 должен прояснить ситуацию. На самом деле, речь идет о наиболее простейшем случае, который возможно представить: одномерная гистограмма с двумя контейнерами. Данная модель гистограммы имеет значение 1.0 для левого контейнера и 0.0 для правого контейнера. Последние три строки показывают сравнение гистограмм и значения сгенерированные различными метриками (метрика EMD будет описана позже).

![Рисунок 7-4 не найден](Images/Pic_7_.jpg)

Рисунок 7-4. Сопоставление гистограмм

Рисунок 7-4 предоставляет наглядное представление сравнения различных типов сопоставления, но есть в этом рисунке кое-что, что может смутить. Если совместить все контейнеры гистограммы в один слот - например, гистограммы из первого и третьего графика сравнения - то все эти методы сопоставления (за исключением EMD) дают максимальное несоответствие, даже при условии, что эти две гистограммы имеют аналогичную "форму". В крайне правом столбце на рисунке 7-4 указаны значения, возвращаемые EMD. Согласно третьей модели, мера EMD количественно изменяет ситуацию, а именно: третья гистограмма смещается вправо на одну единицу. Про данное поведение будет более подробно рассказано в следующем разделе "Earth Mover’s Distance". 

Согласно опыту авторов, пересечение работает хорошо для быстрых и грязных соответствий, а хи-квадрат или Bhattacharyya работает хорошо для медленных, но более точных совпадений. EMD дает более интуитивно понятные совпадения, но при этом работает медленнее.

**Пример использования гистограмм**

