## (П]|(РС)|(РП) Более сложные манипуляции

Всё, что было рассмотрен до сих пор было достаточно простым. Каждая из функций несла очевидную необходимость. В совокупности, они образуют хорошую основу для всего того, что можно сделать с гистограммами в контексте компьютерного зрения (или же в каких-либо других контекстах). В данном разделе речь пойдет о более сложных процедурах, которые имеются в OpenCV и которые чрезвычайно полезны в некоторых приложениях. Эти процедуры включают в себя более сложные методы сравнения двух гистограмм, а так же инструменты для вычисления и/или визуализации частей изображения, которые соответствуют заданной части гистограммы. 

### Earth Mover’s Distance

Изменение освещения может привести к сдвигу цветовых значений (рисунок 7-5), хотя такой сдвиг, как правило, не изменяет форму гистограммы значений цвета, но при изменении положения цветовых значений, схемы сравнения гистограмм обречены на провал. Однако, если вместо гистограмм *сравнения* использовать гистограммы *расстояния*, то можно сравнить две гистограммы несмотря на сдвиг одной гистограммы относительно другой на малые расстояния. Earth mover’s distance (EMD) явлется метрикой; по сути это мера работы необходимой для преобразования одной или нескольких гистограмм в новое положение. Она работает с любым количеством измерений.

Если снова взглянуть на рисунок 7-4, то можно увидеть характер изменения расстояния EMD. Точное совпадение соответствует расстоянию равное 0. (!)Совпадение на половину это половина "полной лопаты" - то количество, которое потребуется, чтобы разнести половину левой гистограммы в соседний слот.(!) И наконец, для перемещения всей гистограммы на один шаг вправо потребует вся единица расстояния (например, для изменения гистограммы в "совершенно несовпадающую " гистограмму).

Алгоритм EMD имеет весьма общий характер; это позволяет пользователям устанавливать собственную дистанционную метрику или собственную матрицу стоимости перемещения. (!)Можно зафиксировать, где гистограмма "material" изменяется при переходе от одной гистограммы к другой или можно воспользоваться нелинейными показателями расстояния, полученные из предварительной информации о данных.(!) В OpenCV EMD соответствует функция *cvCalcEMD2()*:

```cpp
	float cvCalcEMD2(
		 const CvArr* 			signature1
		,const CvArr* 			signature2
		,int 					distance_type
		,CvDistanceFunction 	distance_func 	= NULL
		,const CvArr* 			cost_matrix 	= NULL
		,CvArr* 				flow 			= NULL
		,float* 				lower_bound 	= NULL
		,void* 					userdata 		= NULL
	);
```

Функция *cvCalcEMD2()* имеет достаточно много аргументов. Можно воспринять это решение довольно таки сложным для такой интуитивной функции, но сложность проистекает от возможности тонкой настройки алгоритма (если есть необходимость в знание всех "кровавых" подробностей, то необходимо изучить статью S. Peleg, M. Werman и H. Rom 1989 года "A Unified Approach to the Change of Resolution: Space and Gray-Level", а затем заглянуть в руководство OpenCV и изучить файл *...\opencv\docs\ref\opencvref_cv.htm*). К счастью, функция может быть использована в более обобщенной и интуитивно понятной форме без большинства аргументов (на это указывает "= NULL" в определении функции). В примере 7-2 показана упращенная версия этой функции.

Пример 7-2. Упращенная версия функции cvCalcEMD2()

```cpp
	float cvCalcEMD2(
		 const CvArr* signature1
		,const CvArr* signature2
		,int distance_type
	);
```

Параметр *distance_type* для упращенной версии *cvCalcEMD2()* может быть либо *расстоянием Manhattan* (*CV_DIST_L1*) или *расстоянием Euclidean* (*CV_DIST_L2*). Хотя EMD и используется для гистограмм, интерфейс упрощенной версии функции предполагает использвание в терминологии первых двух аргументов массивов. 

Эти массивы всегда типа *float* и состоят из строк, содержащие количество контейнеров гистограммы и их координаты. Для одномерной гистограммы (рисунок 7-4) сигнатуры (перечислимые строки массива) левой колонки гистограммы (пропускная модель) будет выглядеть следующим образом: верхняя [1, 0; 0, 1]; средняя [0.5, 0; 0.5, 1]; нижняя [0, 0; 1, 1]. Если взять контейнер трехмерной гистограммы с 537 контейнерами (x, y, z), то сигнатура строки с индексом (7, 43, 11) будет [537, 7; 43, 11]. Это необходимый шаг преобразования гистограммы в сигнатуры.

В качестве примера, предположим, что имеется две гистограммы *hist1* и *hist2*, которые необходимо преобразовать в сигнатуры *sig1* и *sig2*. Для усложнения задачи, будут использованы двумерные гистограммы размерностью *h_bins x s_bins*. Пример 7-3 отопражает процесс преобразования этих двух гистограмм в две сигнатуры. 

Пример 7-3. Создание сигнатур гистограмм для EMD сравнения

```cpp
// Преобразование гистограмм в сигнатуры для EMD сравнения
// На входе имеются двумерные гистограммы hist1 и hist2
// обе имеют размерности h_bins x s_bins (хотя для EMD,
// гистограммы не должны совпадать по размеру)
//
CvMat* sig1,sig2;
int numrows = h_bins*s_bins;

// Создание матриц для хранения сигнатур
//
sig1 = cvCreateMat(numrows, 3, CV_32FC1); // 1 count + 2 coords = 3
sig2 = cvCreateMat(numrows, 3, CV_32FC1); // sig1 и sig2 имеют тип float

// Заполнение сигнатур для двух гистограмм
//
for( int h = 0; h < h_bins; h++ ) {
    for( int s = 0; s < s_bins; s++ ) {
    float bin_val = cvQueryHistValue_2D( hist1, h, s );
    cvSet2D(sig1,h*s_bins + s,0,cvScalar(bin_val)); 	// значение контейнера
    cvSet2D(sig1,h*s_bins + s,1,cvScalar(h)); 			// Coord 1
    cvSet2D(sig1,h*s_bins + s,2,cvScalar(s)); 			// Coord 2
 
    bin_val = cvQueryHistValue_2D( hist2, h, s );
    cvSet2D(sig2,h*s_bins + s,0,cvScalar(bin_val)); 	// значение контейнера
    cvSet2D(sig2,h*s_bins + s,1,cvScalar(h)); 			// Coord 1
    cvSet2D(sig2,h*s_bins + s,2,cvScalar(s)); 			// Coord 2
    }
}
```

В этом примере (Использование  cvSetReal2D() или cvmSet() было бы более компактным и эффективным, но пример проясняет выбранный вариант: дополнительные накладные расходы малы по сравнению с фактическими расчетами расстояния в EMD) функция *cvSet2D()* принимает *CvScalar()*, чтобы задать значения массива, хотя каждая запись в данной матрице имеет тип *float*. Для удобства используется встроенный макрос CvScalar(). После получения сигнатур можно вычислять меру расстояния. В примере 7-4 показано вычисление расстояния Euclidean.

Пример 7-4. Использование EMD для измерения сходства между распределениями

```cpp
	float emd = cvCalcEMD2( sig1, sig2, CV_DIST_L2 );
	printf( "%f; ", emd );
```

### Обратная проекция

Обратная проекция это способ записи пикселей (*cvCalcBackProject()*) или участка пикселей (*cvCalcBackProjectPatch(*), соответствующие распределению пикселей в модели гистограммы. Например, имея гистограмму телесного цвета можно воспользоваться обратной проекцией, чтобы найти цвета на изображении, соответствующие кожному цвету. Функция, выполняющая подобного рода поиск:

```cpp
	void cvCalcBackProject(
		 IplImage** 		image
		,CvArr* 			back_project
		,const CvHistogram* hist
	);
```

