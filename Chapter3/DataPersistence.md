## [П]|[РС]|(РП) Сохранность данных

OpenCV предоставляет средства для сериализации и де-сериализации различных типов данных "на" и "с" диска в формате *YAML* или *XML*. В главе HighGUI будут рассмотрены функции пользовательского интерфейса, в частности по работе с изображениями (функции *cvSaveImage()* и *cvLoadImage()*). Так же будут рассмотрены функции чтения и записи видеофайлов: *cvGrabFrame()* - считывает кадр из файла или с камеры, *cvCreateVideoWriter()* и *cvWriteFrame()*. В данном разделе речь пойдет об общем хранении объектов: чтение и запись матриц, OpenCV структуры, файлы конфигурации и логирования.

Для начала будут рассмотрены функции сохранения и загрузки матриц. Это функции *cvSave()* и *cvLoad()*. Например, имеется единичная матрица 5x5 (по диагонали элементы равны 1, остальные 0). 

Пример 3-16. Сохранение и загрузка матрицы
```cpp
	CvMat A = cvMat( 5, 5, CV_32F, the_matrix_data );	// Создание матрицы
	cvSave( "my_matrix.xml", &A );						// Сохранение
	...
	// Чтение ранее сохраненной матрицы
	CvMat* A1 = (CvMat*) cvLoad( "my_matrix.xml" );
```

CxCore содержит целый раздел по сохранности данных. Действительно важно знать, что сохранность данных в OpenCV состоит в создании структуры *CvFileStorage*, которая хранит объекты в памяти в виде дерева. Можно создать и заполнить эту структуру, прочитав данные с диска с помощью *cvOpenFileStorage()* с флагом *CV_STORAGE_READ*, или можно создать и открыть эту структуру с помощью *cvOpenFileStorage()* с флагом *CV_STORAGE_WRITE* для записи, т.е. для заполнения этой структуры данными с помощью соответствующих функций. На диске данные хранятся в формате XML или YAML.

Пример 3-17. Структура CvFileStorage; данные доступны через функции сохранности данных CxCore
```cpp
	typedef struct CvFileStorage
	{
		...	// скрытые поля
	} CvFileStorage;
```

Данные внутри дерева CvFileStorage могут состоять из иерархии скаляров, объектов CxCore (матрицы, последовательности и графики) и/или пользовательских объектов.

Например, необходимо записать на диск файл конфигурации, который содержит количество кадров для записи (10), размер кадра (320x240) и цветную матрицу преобразования 3x3. 

Пример 3-18. Запись конфигурационного файла "cfg.xml" на диск
```cpp
	// Создание файлового хранилища
	CvFileStorage* fs = cvOpenFileStorage(
			 "cfg.xml"
			,0
			,CV_STORAGE_WRITE
		);

	cvWriteInt( fs, "frame_count", 10 );					// Указание количества кадров
	cvStartWriteStruct( fs, "frame_size", CV_NODE_SEQ );	// Создание вложенного узла
	cvWriteInt( fs, 0, 320 );		// Указание ширина кадра
	cvWriteInt( fs, 0, 200 );		// Указание высоты кадра
	cvEndWriteStruct( fs );									// Окончание вложенного узла
	cvWrite( fs, "color_cvt_matrix", cmatrix );				// Указание матрицы преобразования
	cvReleaseFileStorage( &fs );							// Освобождение занимаемой памяти
```

Функция *cvWriteInt()* задает имя тега для скаляра в структуре дерева. Функция *cvStartWriteStruct()* создает контейнер для тегов. Функция *cvEndWriteStruct()* сигнализирует об окончании созданного контейнера. Глубина вложенности может быть произвольной. Функция *cvWrite()* используется для записи цветной матрицы преобразования. После окончания записи, необходимо вызвать функцию *cvReleaseFileStorage()*. Результат выполнения примера 3-18 представлен в примере 3-19.

Пример 3-19. XML файл cfg.xml
```xml
	<?xml version="1.0"?>
	<opencv_storage>
		<frame_count>10</frame_count>
		<frame_size>320 200</frame_size>
		<color_cvt_matrix type_id=“opencv-matrix”>
			<rows>3</rows>
			<cols>3</cols>
			<dt>f</dt>
			<data>...</data>
		</color_cvt_matrix>
	</opencv_storage>
```

Чтение конфигурационного файла показано в примере 3-20

Пример 3-20 Чтение cfg.xml
```xml
	// Открытие файла на чтение
	CvFileStorage* fs = cvOpenFileStorage(
		 "cfg.xml"
		,0
		,CV_STORAGE_READ
	);

	// Получение кол-ва кадров
	int frame_count = cvReadIntByName(
			 fs
			,0
			,"frame_count"
			,5 /* значение по умолчанию */
		);

	// Получение контейнера размера кадра
	CvSeq* s = cvGetFileNodeByName( fs, 0, "frame_size" )->data.seq;

	// Получение ширины кадра
	int frame_width = cvReadInt(
			(CvFileNode*)cvGetSeqElem( s, 0 )
		);

	// Получение высоты кадра
	int frame_height = cvReadInt(
			(CvFileNode*)cvGetSeqElem( s, 1 )
		);

	// Получение матрицы 
	CvMat* color_cvt_matrix = (CvMat*) cvReadByName(
			 fs
			,0
			,"color_cvt_matrix"
		);

	// Освобождение занимаемой памяти
	cvReleaseFileStorage( &fs );
```

Функции сохранности данных, связанные со структурой *CvFileStorage*, описаны в таблице 3-16.

Таблица 3-16. Функции сохранности данных

| Функия | Описание | 
| -- | -- |
| **Открытие и освобождение** | |
| cvOpenFileStorage | Открытие хранилища для чтения и записи |
| cvReleaseFileStorage | Освобождение занимаемой памяти |
| **Запись** | |
| cvStartWriteStruct | Начало записи новой структуры |
| cvEndWriteStruct | Окончание записи новой структуры |
| cvWriteInt | Запись целого числа |
| cvWriteReal | Запись вещественного числа |
| cvWriteString | Запись текстовой строки |
| cvWriteComment | Запись комментария в формате XML или YAML |
| cvWrite | Запись объекта вида CvMat |
| cvWriteRawData | Запись нескольких чисел |
| cvWriteFileNode | Запись узла в другое хранилище |
| Чтение | |
| cvGetRootFileNode | Получение верхнего узла в хранилище |
| cvGetFileNodeByName | Поиск узла в части дерева или хранилище |
| cvGetHashedKey | Получение уникального указателя по переданному имени |
| cvGetFileNode | Поиск узла в части дерева или хранилище |
| cvGetFileNodeName | Получение имени узла |
| cvReadInt | Чтение неименованного целого числа |
| cvReadIntByName | Чтение именованного целого числа |
| cvReadReal | Чтение неименованного вещественного числа |
| cvReadRealByName | Чтение именованного целого числа |
| cvReadString | Чтение неименованной строки |
| cvReadStringByName | Чтение именованной строки |
| cvRead | Декодирование неименованного объекта и получение указателя на него |
| cvReadByName | Декодирование именованного объекта и получение указателя на него |
| cvReadRawData | Чтение нескольких чисел |
| cvStartReadRawData | Чтение узла последовательности |
| cvReadRawDataSlice | Чтение данных из последовательности |
