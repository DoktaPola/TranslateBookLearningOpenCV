## [П]|[РС]|(РП) Рисование

Очень часто будет возникать необходимость рисовать или писать что-либо на изображениях. OpenCV предоставляет нам такую возможность, обладая функциями способными рисовать линии, квадраты, круги и т.д. 

### Линии

Простейшая из всех функций просто рисует линию по алгоритму Bresenham65: 

```cpp
	void cvLine(
		 CvArr* 	array
		,CvPoint	pt1
		,CvPoint	pt2
		,CvScalar	color
		,int 		thickness 		= 1
		,int 		connectivity	= 8
	);
```

Первый аргумент *cvLine()* - *CvArr** указатель на изображение *IplImage**. Следующие два аргумента это координаты точек начала и окончания линии типа *CvPoint*. Напомним, *CvPoint* это структура, содержащая два целочисленных значения *x* и *y*. Можно создать *CvPoint* "на лету" с помощью функции *cvPoint(int x, int y)*. 

Следующий аргумент *color* типа *CvScalar* задает цвет линии. *CvScalar* также является структурой, которая определяется следующим образом:

```cpp
	typdef struct {
		double val[4];
	} CvScalar;
```

Эта структура содержит только массив из четырех чисел типа *double*. Первых три числа массива представляют цвета: красный, зеленый и синий; четвертый не используется (при необходимости используется для альфа канала). Для этого аргумента удобно использовать макрос *CV_RGB(r,g,b)*. Этот макрос принимает три числа и упаковывает их в структуру *CvScalar*.

Следующие два аргумента не обязательны. Параметр *thickness* это толщина линии (в пикселях), а *connectivity* устанавливает тип сглаживания. Тип сглаживания по умолчанию 8 - хорошо сглаженная линия. Можно также установить 4, тогда линия будет менее аккуратна, но зато времени на рисование потребуется намного меньше. 

*cvRectangle()* - ещё одна удобная функция. Из названия понятно, что она рисует прямоугольник. Эта функция имеет те же аргументы, что и *cvLine()*, за исключением аргумента *connectivity*, т.к. стороны прямоугольника в OpenCV всегда параллельны осям координат и сглаживать их нет необходимости. В *cvRectangle()* просто передаются две точки для противоположных углов.

```cpp
	void cvRectangle(
		 CvArr* 	array
		,CvPoint 	pt1
		,CvPoint 	pt2
		,CvScalar 	color
		,int 		thickness = 1
	);
```

### Круги и эллипсы

Так же просто можно нарисовать круг, функция рисования которого в значительной степени имеет те же аргументы.

```cpp
	void cvCircle (
		 CvArr* 	array
		,cvPoint 	center
		,int 		radius
		,CvScalar	color
		,int 		thickness 	= 1
		,int 		connectivity = 8
	);
```

Для круга, прямоугольника и других замкнутых фигур, значение аргумента *thickness* может быть установлено как *CV_FILL*, что эквивалентно значению -1; как результат - фигура будет залита в тот же цвет, что и края. 

Немного более сложная, чем *cvCircle()*, функция * cvEllipse()* рисует эллипс:

```cpp
	void cvEllipse(
		 CvArr* 	img
		,CvPoint 	center
		,CvSize 	axes
		,double 	angle
		,double 	start_angle
		,double 	end_angle
		,CvScalar	color
		,int 		thickness = 1
		,int 		line_type = 8
	);
```

Новый аргумент в этой функции *axes* имеет тип *CvSize*. Структура *CvSize* очень похожа на *CvPoint* и *CvScalar*, только содержит ширину и высоту. Как и для *CvPoint* и *CvScalar* есть вспомогательная функция *cvSize(int width, int height)*, которая возвращает структуру *CvSize*. В данном случае ширина и высота представляют длину большой и малой оси эллипса.

Аргумент *angle* это угол большой оси (в градусах), отсчитываемый от горизонта (т.е. от оси X) против часовой стрелки. Аргументы *start_angle* и *end_angle* указывают углы (в градусах) начала и окончания дуги эллипса. Для цельного эллипса необходимо установить эти значения в 0 и 360 соответственно.

Альтернативный способ нарисовать эллипс — это использовать ограничительную рамку:

```cpp
	void cvEllipseBox(
		 CvArr* 	img
		,CvBox2D 	box
		,CvScalar 	color
		,int 		thickness	= 1
		,int 		line_type	= 8
		,int 		shift 		= 0
	);
```

В функции используется новая вспомогательная структура *CvBox2D*:

```cpp
	typdef struct {
		CvPoint2D32f	center;
		CvSize2D32f		size;
		float 			angle;
	} CvBox2D;
```

Структура *CvPoint2D32f* аналогична *CvPoint*, а *CvSize2D32f* аналогична *CvSize*, только обе вещественного типа. 

### Полигоны

И в заключении, в распоряжении есть множество функций для рисования полигонов:

```cpp
	void cvFillPoly(
		 CvArr* 	img
		,CvPoint**	pts
		,int* 		npts
		,int 		contours
		,CvScalar	color
		,int 		line_type = 8
	);

	void cvFillConvexPoly(
		 CvArr* 	img
		,CvPoint*	pts
		,int 		npts
		,CvScalar	color
		,int 		line_type = 8
	);

	void cvPolyLine(
		 CvArr* 	img
		,CvPoint**	pts
		,int* 		npts
		,int 		contours
		,int 		is_closed
		,CvScalar	color
		,int 		thickness = 1
		,int 		line_type = 8
	);
```

Все три функции реализуют одну и ту же идею, с разницей в том, как представлены точки, по которым рисуется полигон. 

В *cvFillPoly()* точки представляются в виде массива структур *CvPoint*. Это позволяет нарисовать много полигонов в одном вызове. *npts* является массивом количества точек, по одному для каждого полигона. Если переменная *is_closed* установлена в *true*, то последняя точка полигона будет автоматически соединяться с первой. *cvFillPoly()* вполне надежная функция и может обрабатывать самопересекающиеся полигоны, полигоны с отверстиями и полигоны другой сложности. Однако, это влияет на производительность. 

Функция *cvFillConvexPoly()* похожа на *cvFillPoly()*, только рисует один полигон за раз, и работает только с выпуклыми полигонами. Достоинством c*vFillConvexPoly()* является высокое быстродействие.

*cvPolyLine()* принимает те же аргументы что и *cvFillPoly()*, только рисует не закрашенный полигон и следовательно работает гораздо быстрее.

### Шрифты и текст

Ещё одна вещь которая может пригодится при обработке изображений – это отрисовка текста. Конечно текст создаёт собственный набор сложностей, но как всегда в OpenCV есть простой набор инструментов для решения этой задачи (без ненужных возможностей, которые есть в других библиотеках). 

В OpenCV есть одна главная функция *cvPutText()*, которая просто помещает некоторый текст на изображение. Текст указывается в *text* и печатается от нижнего левого угла текстового поля *origin* цвета *color*.

```cpp
	void cvPutText(
		 CvArr* 			img
		,const char*		text
		,CvPoint 			origin
		,const CvFont*		font
		,CvScalar 			color
	);
```

Однако, существуют более сложные задачи, чем просто размещение текст на изображении. Для этих случаев существует указатель *CvFont*.

Для получения валидного указателя *CvFont** используется функция *cvInitFont()*. Эта функция принимает группу аргументов, которые настраивают некоторые особенности шрифта для отображения на экране. Те, кто знаком с программированием GUI в других средах, знакомы с *cvInitFont()*.

Для создания *CvFont* и передачи в *cvPutText()*, необходимо сначала объявить переменную *CvFont* и передать её в *cvInitFont()*.

```cpp
	void cvInitFont(
		 CvFont*	font
		,int 		font_face
		,double		hscale
		,double 	vscale
		,double 	shear 		= 0
		,int 		thickness 	= 1
		,int 		line_type 	= 8
	);
```

Эта функция немного отличается от аналогичных ей, например от *cvCreateImage()*. Структуру CvFont нужно создавать перед вызовом этой функции, в отличии от cvCreateImage(), которая возвращает указатель, в cvInitFont() нужно передать указатель на уже существующую структуру. 

Аргумент *font_face* может быть одним из перечисленных в таблице 3-15 (и изображенном на рисунке 3-6). Также он может быть скомбинирован с *CV_FONT_ITALIC* посредством логического OR.

Таблица 3-15. Доступные шрифты HERSHEY

| Переменная | Описание |
| -- | -- |
| CV_FONT_HERSHEY_SIMPLEX | Нормальный размер без засечек |
| CV_FONT_HERSHEY_PLAIN | Маленький размер без засечек |
| CV_FONT_HERSHEY_DUPLEX | Нормальный размер без засечек; сложнее, чем CV_FONT_HERSHEY_SIMPLEX |
| CV_FONT_HERSHEY_COMPLEX | Нормальный размер без засечек; сложнее, чем CV_FONT_HERSHEY_DUPLEX |
| CV_FONT_HERSHEY_TRIPLEX | Нормальный размер без засечек; сложнее, чем CV_FONT_HERSHEY_COMPLEX |
| CV_FONT_HERSHEY_COMPLEX_SMALL | Уменьшенная версия CV_FONT_HERSHEY_COMPLEX |
| CV_FONT_HERSHEY_SCRIPT_SIMPLEX | Стиль подчерка |
| CV_FONT_HERSHEY_SCRIPT_COMPLEX | Более сложный вариант CV_FONT_HERSHEY_SCRIPT_SIMPLEX |

![Рисунок 3-6 не найден](Images/Pic_3_6.jpg)

Рисунок 3-6. Восемь вариантов шрифта из таблицы 3-15 с hscale = vscale = 1.0  и с междустрочным интервалом в 30 пикселей.

*hscale* и *vscale* могут быть установлены только равными 1.0 или 0.5. Данные параметры задают масштабный коэффициент относительно основного определения конкретного шрифта.

Параметр *shear* устанавливает курсивный шрифт; если установлен в 0.0, шрифт не наклонный. Если параметр равен 1.0, то наклон примерно 45 градусов.

Параметры *thickness* и *line_type* задают толщину и тип сглаживания линии.
