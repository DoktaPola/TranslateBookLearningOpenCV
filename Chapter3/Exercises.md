## [П]|(РС)|(РП) Упражнения

Для получения дополнительной информации при выполнении упражнений обратитесь к документации CxCore или OpenCV Wiki.

1. Найдите и откройте файл *.../opencv/cxcore/include/cxtypes.h*. Изучите его и найдите функции преобразования.
	a. Объявите отрицательное вещественное число и примените функции получения абсолютного значения, округленного значения (*round*, *ceiling*, *floor*)
	b. Сгенерируйте несколько случайных чисел
	c. Создайте вещественную структуру *CvPoint2D32f* и конвертируйте её в целочисленную структуру *CvPoint*
	d. Конвертируйте полученную структуру *CvPoint* обратно в *CvPoint2D32f*

2. Это упражнение научит использовать матрицы. Создайте двухмерную трехканальную матрицу типа байт размера 100x100. Установите все значения в 0.
	a. Нарисуйте круг в матрице, используя *void cvCircle( CvArr* img, CvPoint center,
int radius, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0 )*
	b. Выведите полученное изображение на экран, используя методы, описанные в главе #2

3. Создайте двухмерную трехканальную матрицу типа байт размера 100x100 и установите все значения в 0. С помощью функции *CvPtr2D()* получите доступ к "зелёному" каналу изображения, и нарисуйте прямоугольник между точками (20, 5) и (40, 20).

4. Создайте трехканальное RGB изображение размером 100x100. Очистите его. Используя арифметику указателей, нарисуйте зеленый квадрат между точками (20, 5) и (40, 20).

5. Теперь попрактикуемся в использовании области интереса (ROI). Создайте одноканальное изображение типа байт и размером 210x210 и обнулите его. С помощью ROI и *cvSet()* постройте пирамиду значений, т.е.: внешняя граница должна быть равна 0, следующая внутренняя граница должна быть равна 20, следующая внутренняя граница должна быть равна 40, и так далее, пока конечный внутренний квадрат не будет равен 200; все границы должны быть 10 пикселей в ширину. выведите полученный результат на экран.

6. Загрузите изображение размером не менее 100x100 пикселей. Создайте два дополнительных заголовка изображения и установите их *origin*, *depth*, *nchannels* и *widthstep* как у оригинального изображения. В новых заголовках установите ширину в 20 пикселей, а высоту в 30. Передайте получившиеся заголовки функции в cvNot() и выведите получившиеся изображение на экран.

7. Создайте маску, используя функцию *cvCmp()*. Загрузите любое изображение. Используя функцию ** разбейте загруженное изображение на изображения, содержащие только красный канал от исходного изображения, зеленый канал от исходного изображения и синий канал от исходного изображения.
	a. Выведите на экран изображение, содержащее только зеленый канал
	b. Дважды склонируйте изображение с зеленым каналом, и назовите получившиеся изображения *clone1* и *clone2* 
	c. Найдите максимальное и минимальное значения зеленого канала
	d. Установите значения *clone1* в *thresh = (unsigned char)((maximum - minimum)/2.0)*
	e. Установите значения *clone2* в 0 и вызовите *cvCmp(green_image, clone1, clone2, CV_CMP_GE)* 
	f. В заключении используйте *cvSubS(green_image,thresh/2, green_image, clone2)* и отобразите результат на экране

8. Создайте целочисленную стуктуру, состоящая из *CvPoint* и *CvRect*; назовите её "my_struct"
	a. Напишите две функции *void write_my_struct( CvFileStorage * fs, const char * name, my_struct *ms)* и *void read_my_struct( CvFileStorage* fs, CvFileNode* ms_node, my_struct* ms )* для записи и чтения стуктуры *my_struct*
	b. Запишите и прочтите массив стукрут *my_struct* размером 10