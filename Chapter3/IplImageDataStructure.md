## [П)|(РС)|(РП) Структура IplImage

Теперь, со всеми ранее полученными знаниями, можно перейти к изучению структуры *IplImage*. В сущности это объект *CvMat*, но с некоторыми дополнениями для интерпритации матрицы как изображение. Изначально структура была частью библиотеки IPL (Intel’s Image
Processing). Подробное определение структуры *IplImage* отображает пример 3-10.

Пример 3-10. Заголовок структуры IplImage
```cpp
typedef struct _IplImage {
	int                  nSize;				// sizeof(IplImage)
	int                  ID;				// Версия (=0)
	int                  nChannels;			// Число каналов
	int                  alphaChannel;		// Не используется в OpenCV
	int                  depth; 			// Глубина в битах: IPL_DEPTH_8U, IPL_DEPTH_8S, 
											// IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F и 
											// IPL_DEPTH_64F
	char                 colorModel[4];		// Не используется в OpenCV
	char                 channelSeq[4];		// Не используется в OpenCV
	int                  dataOrder;			// Расположение каналов. 
											// 0 - чередование цветных каналов 
											// 1 - раздельное расположение цветных каналов
	int                  origin;			// Начало координат. 
											// 0 - верхний левый угол
											// 1 - нижний левый угол
	int                  align;				// Выравнивание строк изображения (4 или 8) 
											// В OpenCV используется widthStep
	int                  width;				// Ширина в пикселях
	int                  height;			// Высота в пикселях
	struct _IplROI*      roi;				// ROI. Если NULL, то выделяется все изображение
	struct _IplImage*    maskROI;			// может быть NULL
	void*                imageId;			// может быть NULL
	struct _IplTileInfo* tileInfo;			// может быть NULL
	int                  imageSize;			// Память выделенная под изображение в байтах
											// == image->height*image->widthStep в случае 
											// середования данных
	char*                imageData;			// Указатель на данные изображения
	int                  widthStep;			// Число байт в одной строке изображения
	int                  BorderMode[4];		// Не используется в OpenCV
	int                  BorderConst[4];	// Не используется в OpenCV
	char*                imageDataOrigin;	// Используется для правильного освобождения памяти
} IplImage;
```

Как бы безумно это не прозвучало, но стоит уделить некоторое время для обсуждения некоторых переменных из этой структуры. Некоторые из них просты, однако, многие  очень важны для понимания принципов работы OpenCV с изображениями. 

После вездесущих переменных ширины и высоты, наиболее важными являются переменные глубины и кол-ва каналов. Переменная глубины принимает одно из множества значений, определенных в *ipl.h*, которые (к сожалению) не в полной мере были описаны в главе про матрицы. Это все потому, что для изображений приходиться иметь дело с глубиной и количеством каналов в отдельности (тогда, как в случае с матрицами со всем сразу). Возможные значения глубины перечислены приведены в таблице 3-2.

Таблица 3-2. Типы изображений в OpenCV

| Макрос | Тип изображения |
| -- | -- |
| IPL_DEPTH_8U | Беззнаковое 8-битное целое (8u) |
| IPL_DEPTH_8S | Знаковое 8-битное целое (8s) |
| IPL_DEPTH_16S | Знаковое 16-битное целое (16s) |
| IPL_DEPTH_32S | Знаковое 32-битное целое (32s) |
| IPL_DEPTH_32F | 32-битное типа float (32f) |
| IPL_DEPTH_64F | 64-битное типа double (64f) |

Возможное число каналов - 1, 2, 3, 4.

Следующие немало важные поля структуры *origin* и *dataOrder*. Переменная *origin* может принимать одно из двух значений: *IPL_ORIGIN_TL* или *IPL_ORIGIN_BL*, что соответствует верхнему левому или нижнему левому углу изображения, соответственно. Отсутствие стандартного подхода (верхний против нижний) является важным источником ошибок в процедурах компьютерного зрения. В частности, в зависимости от того, откуда пришло изображение, операционной системы, кодека, формата хранения и т.д. - все это может влиять на расположение начала координат конкретного изображения. Например, можно подумать, что выбрка из пикселей находится на лицевой стороне в верхнем квандранте изображения, в действительности на изнаночной стороне в нижней четверти. Лучше всего проверять этот момент выводом изображения на экран.

Параметр *dataOrder* может принимать значения *IPL_DATA_ORDER_PIXEL* или *IPL_DATA_ORDER_PLANE*. Эти значения указывают каким образом должны быть упакованы данные по каналам, пиксель за пикселем (чередуются или стандартно).

Параметр *widthStep* содержит количество байт между пикселями одного столбца (количество байт в одной строке). Переменной ширины не достаточно для того, чтобы рассчитать расстояние, потому что каждая строка может быть выравнена с определенным числом байт для достижения более быстрой обработки изображения; соответственно, могут существовать зазоры между окончанием i-ой строки и началом (i+1) строки. 

Параметр *imageData* содержит указатель на первую строку данных изображения. Если изображение содержит несколько плоскрстей (когда *dataOrder = IPL_DATA_ORDER_PLANE*), то они размещаются последовательно в виде отдельных изображений с *height*nChannels* строками, но, как правило, они чередуются таким образом, что количество строк равно высоте, а каждая строка содержит чередующие каналы. OpenCV поддерживает только IPL_DATA_ORDER_PIXEL, в то время как IPL/IPP поддерживают IPL_DATA_ORDER_PIXEL и IPL_DATA_ORDER_PLANE.

В заключение, регион интереса (ROI) также важен и является на самом деле экземпляром другой структуры, *IplROI*. *IplROI* содержит *xOffset*, *yOffset*, *width*, *height* и *coi* (канал интересов). Идея использования ROI состоит в том, что функции работают с частью, указанной в ROI, изображения, а не со всем изображением. Все функции работают с ROI, если он установлен. Если COI не NULL, то некоторые операторы будут дейтвовать только на указанном канале, однако, многие функции OpenCV игнорируют этот параметр.

### Доступ к данным изображения

Обычно требуется обрабатывать данные изображения быстро и эффективно. Это означает, что не стоит использовать функции вида *cvSet*D* или аналогичные. На самом деле, лучший путь получения данных изображения, получить данные на прямую. Теперь, зная внутреннее устройство структуры *IplImage*, можно получать данные изображения более быстро и эффективно.

Даже при наличии в OpenCV хорошо оптимизированных продецур, выполняющих большой спектр задач, всегда найдутся такие задачи, с которыми эти процедуры не справятся. Рассмотрим случай трехканального HSV изображения, в котором будем изменять насыщенность и значение цвета от 0 до 255 (максимальное значение для 8-битного изображения), оставляя оттенок неизменным. Лучше всего сделать это с использованием указателя, также как это было сделано с матрицами в примере 3-9. Тем не менее есть незначительные отличия, которые связаны с отличиями в устройстве структур *IplImage* и *CvMat*. Пример 3-11 отражает наибыстрый способ обработки изображения из описанного ранее примера.

Пример 3-11. 
