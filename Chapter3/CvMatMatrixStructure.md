## [П)|(РС)|(РП) Структура CvMat

Прежде, чем начать обсуждение данной темы, уточним несколько вещей относительно матриц. Во первых, в OpenCV нет конструкции "vector". Когда требуется вектор, просто воспользуйтесь матрицей с одной колонкой (или одной строкой, если требуется транспонированный или сопряженный вектор). Во вторых, понятие матрицы в OpenCV несколько абстрактно, нежели в линейной алгебре. В частности, элементы матрицы не обязательно должны быть просто числами. К примеру, создание новой двумерной матрицы имеет следующий прототип:

```cpp
	cvMat* cvCreateMat ( int rows, int cols, int type );
```

Здесь type может быть любым из длинного списка предопределенных типов, тип задаётся так: *CV_<глубина в битах>(S|U|F)C<число каналов>*. Например, матрица может состоять из 32-битных чисел с плавающей точкой(*CV_32FC1*), 8-битных беззнаковых триплетов(*CV_8UC3*) и из множества других. Элементами *CvMat* могут быть не только числами. Возможность представить один элемент составным значением позволяет делать такие вещи, как предствалять несколько цветовых каналов в изображении RGB. С простыми изображениями, содержащих красную, зелёную и синюю составляющую, большинство операторов будут работать с каждым каналом по отдельности (если не указано обратное). 

Внутренняя структура *CvMat* является довольно таки простой, что доказывает пример 3-1 (так же в этом можно убедиться, открыв файл .../opencv/cxcore/include/cxtypes.h). Матрицы имеют ширину, высоту, тип, шаг (длина строки в байтах, а не в *int* или *float*) и указатель на массив данных (и еще несколько вещей, о которох пока не будет рассказано). Получить доступ к элементам матрицы можно непосредственно через указатель на *CvMat* или через специальные функции. Например, для получения размера матрицы можно либо вызвать функцию *cvGetSize(CvMat*)*, либо непосредственно обратиться к соответствующим полям через указатель как *matrix->height* и *matrix->width*.

Пример 3-1. Структура CvMat
```cpp
typedef struct CvMat {
	int type;		// Тип элементов
	int step;		// Шаг
	int* refcount;	// Только для внутреннего использования	
	union {
		uchar*	ptr;
		short*	s;
		int* 	i;
		float*	fl;
		double*	db;
	} data;	// Данные матрицы
	union {
		int rows;	// Кол-во строк
		int height;	// Высота
	};
	union {
		int cols;	// Кол-во столбцов
		int width;	// Ширина
	};
} CvMat;
```

Эта информация обычно именуется заголовном матрицы. Многие подпрограммы разделяют заголовок и данные, причем данные представлены указателем. 

Матрицы могут быть созданы несколькими способами. Наиболее распространенным является подход с использованием *cvCreateMat()*, которая по существу использует более элементарные функции *cvCreateMatHeader()* и *cvCreateData()*. *cvCreateMatHeader()* создает структуру *CvMat*, без выделения памяти под данные, в то время, как *cvCreateData()* выделяет память под данные. По тем или иным причиным, порой, требуется создание лишь заголовка матрицы. Ещё один метод заключается в вызове функции *cvCloneMat(CvMat*)*, которая создает новую матрицу на основе существующей. Когда матрица больше не нужна, память из под неё может быть освобождена вызовом функции *cvReleaseMat(CvMat**)*.

В примере 3-2 представлен список функций, которые только что были описаны, а так же некоторые другие, связанные с ними.

Пример 3-2. Создание и уничтожение матриц
```cpp
	// Создание rows by cols матрицы типа ‘type’.
	CvMat* cvCreateMat( int rows, int cols, int type );

	// Создание только заголовка матрицы
	CvMat* cvCreateMatHeader( int rows, int cols, int type );
	
	// Инициализация заголовка уже существующей матрицы
	CvMat* cvInitMatHeader(
		CvMat* mat,
		int rows,
		int	cols,
		int	type,
		void* data = NULL,
		int	step = CV_AUTOSTEP
	);

	// Похожа на cvInitMatHeader()
	CvMat cvMat(
		int rows,
		int cols,
		int type,
		void* data = NULL
	);

	// Создание новой матрицы на основе существующей
	CvMat* cvCloneMat( const cvMat* mat );
	
	// Освобождение памяти из под матрицы
	void cvReleaseMat( CvMat** mat );
```

По аналогии с другими структурами OpenCV для *CvMat* также есть конструктор *cvMat()*. Конструктор не выделяет память под данные, а лишь создаёт заголовок (по аналогии с *cvInitMatHeader()*). Хороший способ создать матрицу из уже имеющихся данных показан в примере 3-3. 

Пример 3-3. Создание матрицы из уже существующих данных
```cpp
	float vals[] = { 0.866025, -0.500000, 0.500000, 0.866025 }; // Данные
	CvMat rotmat;
	cvInitMatHeader(
		 &rotmat	// Матрица
		,2			// Кол-во строк
		,2			// Кол-во столбцов
		,CV_32FC1	// Тип
		,vals		// Данные
	);
```

После того, как матрица создана, можно производить над ней множество интересных действий. 
	
	cvGetElemType( const CvArr* arr )
	cvGetDims( const CvArr* arr, int* sizes=NULL )
	cvGetDimSize( const CvArr* arr, int index )

Первая функция возвращает тип элемента матрицы (например CV_8UC1, CV_64_FC4 и т.д.). Вторая принимает указатель на массив и дополнительный указатель на целое число; возвращает количество измерений (в примере матрица 2х2). Если указатель на число не NULL, то будет возвращена размерность принимаемого массива. Последняя функция принимает целое число, указывающее размер в процентах и просто возвращает степень матрицы в указанном измерении.

### Доступ к данным матрицы

Существует три варианта получения данных матрицы: простой, сложный и правильный.

*Простой способ*

Самый простой способ получить данные матриц это воспользоваться макросом *CV_MAT_ELEM()*. Этот макрос (пример 3-4) принимает в качестве аргументов указатель на матрицу, тип элементов, сроку и столбец, а возвращает запрашиваемый элемент.

Пример 3-4. Доступ к данным матрицы через макрос CV_MAT_ELEM
```cpp
	CvMat* mat = cvCreateMat( 5, 5, CV_32FC1 );				// Создание матрицы
	float element_3_2 = CV_MAT_ELEM( *mat, float, 3, 2 );	// Получение элемента матрицы
```

"Под капотом" этот макрос просто вызывает другой макрос *CV_MAT_ELEM_PTR()*. Этот макрос (пример 3-5) принимает в качестве аргументов указатель на матрицу, номер строки и столбца запрашиваемого элемента и возвращает указатель на нужный элемент. Одно важное отличие *CV_MAT_ELEM()* от *CV_MAT_ELEM_PTR()* в том, что *CV_MAT_ELEM()* преобразует указатель в соответствии с типом. Если требуется задать значение элементу матрицы, то нужно непосредственно вызвать *CV_MAT_ELEM_PTR()*; при этом, однако, необходимо сделать приведение типов в явном виде.

Пример 3-5. Установка значения элемента матрицы, используя макрос CV_MAT_ELEM_PTR()
```cpp
	CvMat* mat = cvCreateMat( 5, 5, CV_32FC1 );					// Создание матрицы
	float element_3_2 = 7.7;									// Значение элмента в строке #3 и в столбце #2
	*( (float*)CV_MAT_ELEM_PTR( *mat, 3, 2 ) ) = element_3_2;	// Установка элемента
```

К сожалению эти макросы пересчитывают смещение указателя каждый раз при их вызове. Это означает, что указатель каждый раз указывает на первый элемент матрицы; происходит вычисление смещения и добавление полученного значения смещения к указателю на первый элемент матрицы. Таким образом, хоть эти макросы и просты в использвании, это не лучший способ получения доступа к данным матрицы. Лучшим примером против использования данного подхода является вариант последовательного перебора элементов матрицы. 

*Сложный способ*

Два макроса которые были рассмотрены в простом способе, могут работать только с одно- и двумерными матрицами (одномерные массивы или вектора, на самом деле, просто матрица 1xn матрица). OpenCV предоставляет механизмы для обработки многомерных массивов. Фактически OpenCV позволяет обрабатывать n-мерные матрицы "условно любого"" размера.

Для получения доступа к элементам матрицы используется семейство функций *cvPtr*D* и *cvGet*D* описанные в примере 3-6 и 3-7. Семейство *cvPtr*D* содержит *cvPtr1D()*, *cvPtr2D()*, *cvPtr3D()* и *cvPtrND()*. Каждая из первых трех принимает указатель на матрицу *CvArr**, соответствующее количество целых индексов и необязательный параметр, указывающий на тип выходного параметра. Все эти процедуры возвращают указатель на необходимый элемент. *cvPtrND()* вторым аргументом принимает указатель на массив, содержащий соответствующее количество индексов. 

Пример 3-6. Доступ к элементам матрицы через указатель
```cpp
	uchar* cvPtr1D(
		 const CvArr* 	arr
		,int 			idx0
		,int*			type = NULL
	);

	uchar* cvPtr2D(
		 const CvArr* 	arr
		,int 			idx0
		,int			idx1
		,int* 			type = NULL
	);

	uchar* cvPtr3D(
		 const CvArr* 	arr
		,int 			idx0
		,int 			idx1
		,int 			idx2
		,int* 			type = NULL
	);

	uchar* cvPtrND(
		 const CvArr*	arr
		,int*			idx
		,int*			type 			= NULL
		,int 			create_node 	= 1
		,unsigned*		precalc_hashval = NULL
);
```

