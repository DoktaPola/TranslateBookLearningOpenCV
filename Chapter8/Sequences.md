## (П]|(РС]|(РП) Последовательности

Одним из типов объектов, который может хранить хранилище является *последовательность*. Последовательности – это самостоятельно связанные списки разных структур. OpenCV может сделать последовательность из множества различных объектов. В этом смысле можно думать о последовательности как о нечто похожим на общий контейнер классов (или шаблон контейнера классов), который существует в различных языках программирования. Конструкция последовательности в OpenCV выглядит в виде симметричной очереди, так что это позволяет быстро получать произвольный доступ и добавлять/удалять объекты с любого конца очереди, но при этом немного медленнее в случае добавления и удаления объектов в середину очереди. 

Непосредственно внутри самой структуры (пример 8-1) есть некоторые важные элементы, о которых необходимо знать. Во-первых, чаще всего будет использоваться элемент *total*. Это общее количество точек или объектов в последовательности. Следующими четырьмя важными элементами являются указатели на другие последовательности: *h_prev*, *h_next*, *v_prev* и *v_next*. Эти четыре указателя являются частью так называемого элемента *CV_TREE_NODE_FIELDS*; они используются не для указания на элемент последовательности, они нужны для соединения различных последовательностей друг с другом. Другие объекты OpenCV так же содержат эти поля узлов дерева. Любые такие объекты могут быть собраны при помощи этих указателей в более сложные супер структуры такие, как списки, деревья и графы. Переменные *h_prev* и *h_next* могут быть использованы для создания простого связного списка. Другие две переменные *v_prev* и *v_next* могут быть использованы для создания более сложной топологии, которая связывает узлы друг с другом. Именно с помощью этих четырех указателей функция *cvFindContours() * способна представить все найденные контуры, составленные в сложную структуру в виде дерева контуров.

Пример 8-1. Внутренняя организация структуры последовательности CvSeq

```cpp
typedef struct CvSeq {
	int 			flags; 			// различные флаги
	int 			header_size; 	// размер заголовка последовательности
	CvSeq* 			h_prev; 		// горизонтально-предыдущая последовательность
	CvSeq* 			h_next; 		// горизонтально-следующая последовательность
	CvSeq* 			v_prev; 		// вертикально-предыдущая последовательность
	CvSeq* 			v_next 			// вертикально-следующая последовательность
	int 			total; 			// общее количество элементов
	int 			elem_size; 		// размер элемента последовательности в байтах
	char* 			block_max; 		// максимальный предел последнего блока
	char* 			ptr; 			// текущий указатель записи
	int 			delta_elems; 	// сколько элементов выделять при росте последовательности
	CvMemStorage* 	storage; 		// где хранить последовательность
	CvSeqBlock* 	free_blocks; 	// список свободных блоков
	CvSeqBlock* 	first; 			// указатель на первый блок последовательности
}
```

### Создание последовательности

Как уже было сказано ранее, многие функции OpenCV могут возвращать последовательности. В добавок к этому существует возможность создавать собственные последовательности. Как и для большинства объектов OpenCV, существует функция создающая последовательности и возвращающая указатель на эту последовательность. Эта функция называется *cvCreateSeq()*:

```cpp
	CvSeq* cvCreateSeq(
		 int 			seq_flags
		,int 			header_size
		,int 			elem_size
		,CvMemStorage* 	storage
	);
```

Эта функция запрашивает некоторые дополнительные флаги, которые указывают какая именно последовательность создается. Кроме того необходимо указывать размер заголовка последовательности (всегда *sizeof(CvSeq)*) и размеры объектов, которые содержит последовательность. И наконец, необходимо хранилище, которое будет использовано для выделения памяти под последовательность при добавлении нового элемента в последовательность.

Флаги *flags* бывают трех различных категорий и могут быть объединены с помощью оператора побитового *OR*. Первая категория определяет тип объектов из которых будет создана последовательность (Типы в данной категории используются редко. Чтобы создать последовательность, элементами которой являются кортежи чисел, нужно использовать *CV_32SC2*, *CV_32FC4* и т.д. Для создания последовательности элементов собственного типа, необходимо передать 0 и указать правильный размер *elem_size*). Многие из этих типов могут быть не знакомыми, а некоторые в первую очередь предназначены для других функций OpenCV. К тому же некоторые флаги имеет смысл использовать только с определенными типами последовательностей (например, *CV_SEQ_FLAG_CLOSED* имеет смысл использовать только для последовательностей, представляющие многоугольники)

```cpp
	CV_SEQ_ELTYPE_POINT
		(x,y)

	CV_SEQ_ELTYPE_CODE
		Код Freeman: 0..7

	CV_SEQ_ELTYPE_POINT
		Указатель на точку: &(x,y)

	CV_SEQ_ELTYPE_INDEX
		Целочисленный индекс точки: #(x,y)

	CV_SEQ_ELTYPE_GRAPH_EDGE
		&next_o,&next_d,&vtx_o,&vtx_d
	
	CV_SEQ_ELTYPE_GRAPH_VERTEX
		first_edge, &(x,y)
	
	CV_SEQ_ELTYPE_TRIAN_ATR
		Вершина бинарного дерева
	
	CV_SEQ_ELTYPE_CONNECTED_COMP
		Связная компонента
	
	CV_SEQ_ELTYPE_POINT3D
		(x,y,z)
```

Вторая категория указывает на характер последовательности, который может быть любым из ниже перечисленных.

```cpp
	CV_SEQ_KIND_SET
		Множество объектов
	
	CV_SEQ_KIND_CURVE
		Кривая определенная объектами
	
	CV_SEQ_KIND_BIN_TREE
		Бинарное дерево объектов

	CV_SEQ_KIND_GRAPH
		Граф с объектами в узле
```

Третья категория состоит из флагов, которые указывают некоторые дополнителные свойства последовательности

```cpp
	CV_SEQ_FLAG_CLOSED
		Закрытая последовательность (многоугольники)
	
	CV_SEQ_FLAG_SIMPLE
		Простая последовательность (многоугольники)
	
	CV_SEQ_FLAG_CONVEX
		Выпуклая последовательность (многоугольники)
	
	CV_SEQ_FLAG_HOLE
		Вогнутая последовательность (многоугольники)
```

### Удаление последовательности

```cpp
	void cvClearSeq(
		 CvSeq* seq
	);
```

Для удаления последовательности можно использовать функцию *cvClearSeq()*, которая очистит все элементы последовательности. Однако, эта функция не возвращает хранилищу или системе выделяемые под них блоки; память, выделенная последовательностью может быть повторно использована только этой же последовательностью. Если необходимо использовать память для других целей, необходимо очистить память хранилища при помощи *cvClearMemStore()*.

### Прямой доступ к элементам последовательности

Зачастую будет возникать необходимость прямого доступа к конкретному элементу последовательности. Есть несколько способов сделать это, однако, самый прямой и правильный путь получения доступа к случайно выбранному элементу () использовать *cvGetSeqElem()*.

```cpp
	char* cvGetSeqElem( seq, index )
```

Часто будет возникать необходимость приводить возвращаемый указатель к любому из типов, из которых может состоять последовательность. Следующий пример показывает как с помощью *cvGetSeqElem()* распечатать элементы последовательности точек (могут быть возвращены функцией *cvFindContours()*, которая будет рассмотрена чуть позже): 

```cpp
	for( int i=0; i<seq->total; ++i ) {
		CvPoint* p = (CvPoint*)cvGetSeqElem ( seq, i );
		printf("(%d,%d)\n", p->x, p->y );
	}
```

В добавок к этому при помощи функции *cvSeqElemIdx* можно узнать где в последовательности расположен конкретный элемент:

```cpp
	int cvSeqElemIdx(
		const CvSeq* 	seq
		const void* 	element
		CvSeqBlock** 	block = NULL
	);
```

Выполнение данной функции занимает некоторое время, так что это не очень эффективная операция (время поиска пропорционально количеству элементов в последовательности). Стоит обратить внимание на то, что *cvSeqElemIdx()* принимает в качестве аргумента указатель на последовательность и указатель на элемент, который ищется. (Правильнее было бы сказать, что *cvSeqElemIdx()* принимает разыскиваемый указатель. Так происходит потому-что cvSeqElemIdx() не ищет элемент в последовательности который равен **element*, а скорее ищет элемент который находится на месте *element*) Так же можно передать указатель на блок памяти последовательности. Если *block != NULL*, тогда будет возвращено расположение блока в котором был найден элемент последовательности. 

### Деление на части, копирование и перемещение данных