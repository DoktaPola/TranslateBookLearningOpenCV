## [П]|[РС]|(РП) Вторая программа - AVI видео

Воспроизводить видео в OpenCV почти также легко, как и показ одного изображения. Разница лишь в том, что нужно организовать некий цикл для обработки последовательности кадров; также нужен способ для выхода из цикла, если фильм скучный. 

Пример 2-2. Простая программа для воспроизведения видеофайла с диска при помощи OpenCV
```cpp
#include “highgui.h”

int main( int argc, char** argv ) 
{
	cvNamedWindow( "PlayVideo", CV_WINDOW_AUTOSIZE );		// Создание окна
	CvCapture* capture = cvCreateFileCapture( argv[1] );	// Открытие видеофайла для формирования структуры CvCapture
	IplImage* frame;										// Кадр
	while(1) 
	{
		frame = cvQueryFrame( capture );	// Последовательное чтение кадров
		if( !frame ) break;					// Конец файла, кадров больше нет
		cvShowImage( "PlayVideo", frame );	// Отображение кадра
		char c = cvWaitKey(33);				// Ожидание 33 мс
		if( c == 27 ) break;				// Если Esc - выход из цикла
	}
	cvReleaseCapture( &capture );	// Закрытие файла
	cvDestroyWindow( "PlayVideo" );	// Уничтожение окна
}
```

Функция *main()* начинается с создания окна, в примере имя окна "PlayVideo". После начинается самое интересное.

```cpp
	CvCapture* capture = cvCreateFileCapture( argv[1] );
```

Функция *cvCreateFileCapture()* принимает в качестве аргумента имя видеофайла, а возвращает указатель на структуру типа CvCapture. Эта структура содержит всю информацию из видеофайла, включая информацию о состоянии. 

```cpp
	frame = cvQueryFrame( capture );
```

После, в цикле *while(1)*, происходит чтение видеофайла кадр за кадром. Функция *cvQueryFrame()* принимает в качестве аргумента указатель на структуру **CvCapture** и помещает последующий кадр в память (которая на самом деле часть структуры **CvCapture**). Возвращает указатель полученного кадра. В отличии от *cvLoadImage()*, которая выделяет память под изображение, *cvQueryFrame()* использует выделенную память в структуре **CvCapture**. Поэтому не требуется использовать *cvReleaseImage()* для указателя на "кадр". Вместо этого память из-под кадра будет освобождена, когда произойдет уничтожение структуры **CvCapture**. 

```cpp
	c = cvWaitKey(33);
	if( c == 27 ) break;
```

После отображения кадра, программа будет ожидать нажатие клавиши в течении 33 мс. Если пользователь нажмет клавишу, то будет получен ASCII код этой клавиши; иначе будет получена -1. Если пользователь нажмет Esc (ASCII 27), то чтения кадров прекратиться. Если в течении 33 мс пользователь не нажмет клавишу, то произойдет чтение последующего кадра. 

Стоит отметить, что в этом простом примере, не происходит явного контроля скорости воспроизведения видео. Все зависит лишь от таймера *cvWaitKey()*. В более сложном проекте было бы целесообразно полагаться на скорость из структуры **CvCapture**. 

```cpp
	cvReleaseCapture( &capture );
```

После окончания воспроизведения видеофайла - обработаны все кадры или пользователь нажал Esc - необходимо освободить память, связанную со структурой **CvCapture**.
