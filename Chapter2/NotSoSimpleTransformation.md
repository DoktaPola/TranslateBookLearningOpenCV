## [П]|[РС]|(РП) Не столь простые преобразования

Уже не плохо, переходим к еще более интересным вещам. В примере 2-4 создавалась новая структура под единичное преобразование изображения. По идеи, существует возможность работать только с исходным изображением, без создания дополнительного контейнера под преобразованное изображение, но зачастую это плохая идея. Например, некоторые операторы не работают с изображениями такого же размера, типом каналов и количеством каналов, как исходное изображение. Как правило, производиться цепочка преобразований и потому использование стороннего контейнера неизбежно. 

В таких случаях, зачастую полезно использовать функции-обертки, чтобы произвести все необходимые преобразования. Рассмотрим пример сжатия изображения в 2 раза. В OpenCV это достигается при помощи функции *cvPyrDown()*, которая выполняет гауссово сглаживание, а затем удаляет каждую вторую строку из изображения. Это полезно в самых разнообразных и важных алгоритмах компьютерного зрения. Реализация функции-обертки представлена в примере 2-5.

Пример 2-5. Использование *cvPyrDown()* для сжатия исходного изображения в 2 раза

```cpp
IplImage* doPyrDown( IplImage* in, int filter = IPL_GAUSSIAN_5x5 ) {
    // Проверка деления исходного изображения на 2
    // 
    assert( 0 == in->width%2 && 0 == in->height%2 );

    // Создание контейнера с размером вдвое меньшим, чем исходное изображение. 
    // В остальном параметры те же
    // 
    IplImage* out = cvCreateImage(
         cvSize( in->width/2, in->height/2 )
        ,in->depth
        ,in->nChannels
    );

    // Сжатие исходного изображения
    // 
    cvPyrDown( in, out );

    return( out );
};
```

Обратите внимание, что под преобразованное изображение создается новая структура на основе параметров исходного изображения. В OpenCV все важные типы данных реализованы как структуры, в которых нет private данных, и все крутится вокруг указателей на эти структуры.

Переходим к чуть более сложному примеру с использованием функции определения контура **Canny edge detector**. В этом примере конечное изображение сохранит исходные размеры, но воспользуется только одним каналом. 

Пример 2-6. Определение контура при помощи функции Canny. Результат - одноканальное изображение

```cpp
IplImage* doCanny(
     IplImage*  in          // Одноканальное изображение
    ,double     lowThresh   // Нижний порог
    ,double     highThresh  // Верхний порог
    ,double     aperture    // Размер оператора Собеля
) {
    // Canny работает только с одноканальными изображениями
    // 
    if( 1 != in->nChannels ) {
        return(0);
    }

    // Создание контейнера под конечное изображение
    // 
    IplImage* out = cvCreateImage(
         cvSize( cvGetSize( in ) )
        ,IPL_DEPTH_8U
        ,1
    );

    // Преобразования
    // 
    cvCanny( in, out, lowThresh, highThresh, aperture );
    
    return( out );
};
```

В итоге, можно довольно-таки легко соединять несколько различных операторов. Например, требуется уменьшить изображение в два раза, а затем найти контур в уменьшенном еще раз вдвое изображении.

Пример 2-7. Сочетание сжатия изображения (дважды) и оператора *Canny*

```cpp
IplImage* img1 = doPyrDown( in, IPL_GAUSSIAN_5x5 );
IplImage* img2 = doPyrDown( img1, IPL_GAUSSIAN_5x5 );
IplImage* img3 = doCanny( img2, 10, 100, 3 );

// делаем что-нибудь с img3
...
// 

cvReleaseImage( &img1 );
cvReleaseImage( &img2 );
cvReleaseImage( &img3 );
```

Важно отметить, что создание дополнительных переменных под каждое преобразование не является хорошей идеей. Зачастую, из-за своей лени, происходит утечка памяти в связи с отсутствием соответствующей функции освобождения памяти *cvReleaseImage()* в функции-обертки.

Механизм "само очистки" будет более аккуратным, если использовать эту функцию, однако существует еще одна проблема: что, если нам потребуется что-то сделать с промежуточным изображением? Ничего может не получиться из-за возможного отсутствия доступа к этому изображению. Решить проблему поможет подход из примера 2-8.

Пример 2-8. Упрощение примера 2-7

```cpp
IplImage* out;
out = doPyrDown( in, IPL_GAUSSIAN_5x5 );
out = doPyrDown( out, IPL_GAUSSIAN_5x5 );
out = doCanny( out, 10, 100, 3 );

// делаем что-нибудь с 'out'
...
// 

cvReleaseImage ( &out );
```

В заключении, стоит отметить, что освобождать память необходимо из-под выделяемой под преобразования структуры. Рассмотрим небольшой пример: указатель *IplImage*, возвращаемый *cvCreateFileCapture()*, указывает на структуру типа **CvCapture** и инициализируется только в момент загрузки видеофайла. Освобождение памяти, вызовом функции *cvRealeaseImage()*, приведет к некоторым неожиданным проблемам. Мораль сей басни такова: очистка мусора важна, но только мусора, которой создавали сами!

