## [П]|[РС]|(РП) Создание ползунка

Хорошо, уже не плохо. Теперь пришло время расширить функциональность нашей программы. Первое, что бросается в глаза в примере 2-2 - это отсутствие возможности передвигаться по видео. Следующей задачей будет добавление ползунка, который позволит устранить эту проблему.

Инструментарий *HighGUI* предоставляет ряд простых средств для работы с изображениями и видео. Одним из таких механизмов является слайдер, который с лёгкостью перемещает с одного конца видео в другой. Для создания ползунка необходимо вызвать функцию *cvCreateTrackBar()*, указать окно, в котором этот ползунок появится и установить функцию-обработчик. Детали реализации в примере 2-3.

Пример 2-3. Программа добавления слайдера; при перемещении ползунка, происходит вызов *onTrackbarSlider()* и установка нового значения слайдера

```cpp
#include “cv.h”
#include “highgui.h”

int         g_slider_position   = 0;    // Позиция ползунка
CvCapture*  g_capture           = NULL; // Структура для видеофайла

// Вызывается каждый раз, когда происходит изменение положения ползунка 
// 
void onTrackbarSlide( int pos ) {
    // Установка свойства: положение
    // 
    cvSetCaptureProperty(
         g_capture
        ,CV_CAP_PROP_POS_FRAMES
        ,pos // Номер кадра
    );
}

int main( int argc, char** argv ) {
    cvNamedWindow( "TrackBar", CV_WINDOW_AUTOSIZE );    // Создание окна
    g_capture = cvCreateFileCapture( argv[1] );         // Открытие видеофайла для формирования структуры

    // Получение кол-ва кадров
    // 
    int frames = (int) cvGetCaptureProperty(
         g_capture
        ,CV_CAP_PROP_FRAME_COUNT
    );

    if( 0 != frames ) {
        // Создание ползунка
        // 
        cvCreateTrackbar(
             "Position"         // Имя ползунка
            ,"TrackBar"         // Окно для вывода ползунка
            ,&g_slider_position // Начальная позиция
            ,frames             // Максимальная позиция
            ,onTrackbarSlide    // Функция обработчик
        );
    }

    IplImage* frame; // Кадр
    
    // Цикл последовательного чтения кадров (пример 2-2)
    ...
    // Освобождение памяти и уничтожение окна
    ...
    
    return(0);
}
```

В сущности, стратегия заключается в добавлении глобальной переменной для хранения позиции слайдера и функции-обработчик для обновления этой переменной. Давайте взглянем на детали.

```cpp
int         g_slider_position   = 0;
CvCapture*  g_capture           = NULL;
```

Во-первых, нужно определить глобальную переменную для позиции ползунка. Функции-обработчик требуется объект захвата, поэтому соответствующая переменная также объявлена глобально. Поступим как хорошие люди и сделаем наш код легко читаемым и понятным. Для этого добавим ведущую приставку g_ к нашим переменным. 

```cpp
    void onTrackbarSlide(int pos) {
        cvSetCaptureProperty(
             g_capture
            ,CV_CAP_PROP_POS_FRAMES
            ,pos
        );
    }
```

Функция-обработчик вызывается каждый раз, когда пользователь изменяет положение ползунка. Эта функция принимает 32-разрядное целое число, которое устанавливает положение ползунка.

Вызов функции *cvSetCaptureProperty()*, наряду с функцией *cvGetCaptureProperty()*, является наиболее используемой функцией. Эти функции позволяют настроить различные свойства объекта **CvCapture**. В нашем случае, флаг *CV_CAP_PROP_POS_FRAMES* указывает на то, что устанавливается позиция для чтения кадров в единицах (также можно использовать *AVI_RATIO* вместо *FRAMES*, если потребуется установить позицию в процентах). Как результат - новое положение позиции ползунка. Библиотека **HighGUI** довольно-таки умна и потому такие ситуации, как запрос к не ключевому кадру будут обрабатываться автоматически; произойдет откат назад к ближайшему ключевому кадру и уже от него произойдет перемотка вперед до нужного кадра.

```cpp
int frames = (int) cvGetCaptureProperty(
     g_capture
    ,CV_CAP_PROP_FRAME_COUNT
);
```

Как было отмечено ранее, для получения данных из структуры *CvCapture* используется функция *cvGetCaptureProperty()*. В нашем случае, требуется узнать количество кадров в видео для откалиброки ползунка.

```cpp
    if( 0 != frames ) {
        cvCreateTrackbar(
             “Position”
            ,“TrackBar”
            ,&g_slider_position
            ,frames
            ,onTrackbarSlide
        );
    }
```

Для создания ползунка используется функция *cvCreateTrackbar()*, которая принимает в качестве аргументов: имя объекта ползунка, имя окна, переменную положения ползунка, максимальное значение ползунка и функцию-обработчик (или NULL). Ползунок не будет создан, если *cvGetCaptureProperty()* возвратит ноль кадров. Такое возможно, так как общее количество кадров может быть не доступно из-за используемого метода кодирования видеофайла. В таком случае прокрутить видео будет не возможно. 

Ползунок из *HighGUI* не является полнофункциональным. Несомненно, существует возможность использовать иные варианты создания ползунка сторонними средствами для устранения этой проблемы, однако, использование ранее описанного подхода позволяет легко и быстро создать простой в использовании ползунок.

И в заключении, не был рассмотрен кусок кода, необходимый для отображения авто перемещения ползунка поверх видео. Эта задача остается в качестве упражнения.

