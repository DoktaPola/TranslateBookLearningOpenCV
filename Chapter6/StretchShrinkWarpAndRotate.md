## (П]|(РС)|(РП) Растягивание, сжатие, деформация и поворот

В этом разделе речь пойдет о геометрических манипуляциях над изображениями (об этих преобразования довольно таки подробно будет рассказано в этом разделе и в главе 11, когда они будут использованы в контексте трехмерного компьютерного зрения). Такие манипуляции включают в себя разтягивания в различных направлениях, при этом речь может идти как об однородных, так и об неоднородных изменениях размера (последнее более известно как *деформация*). Есть множество причин, чтобы выполнить эти операции: например, деформируя и поворачивая изображение так, чтобы уместить его в существующей сцене или для искусственного увеличения набора шаблонных изображений, используемых для распознавания объектов (это может показаться хитроумным; в конце концов, почему бы просто не использовать метод распознавания, инвариантный к локальным аффинным искажениям? Тем не менее, этот метод имеет долгую историю и до сих пор может быть весьма полезным на практике). Функции, которые могут растягивать, сжимать, деформировать и/или поворачивать изображение именуются *геометрическими трансформациями*. Для плоскости есть две разновидности геометрических преобразований: преобразование, которое использует матрицу 2x3 и именуется *аффинным преобразованием*; и преобразование, которое использует матрицу 3x3 и именуется *перспективным преобразованием* или *гомографией*. Для последнего преобразования нужно представить, что оно основано на методе для вычисления пути, по которому в трехмерном измерении направлен взор конкретного наблюдателя, так как прямо взглянуть на эту плоскость он не может.

Аффинные преобразования - это любые преобразования, которые могут быть выражены в виде последовательного перемножения матриц и сложения с некоторым вектором. В OpenCV стандартной  для таких преобразованиях является матрица размера 2x3. 

![Формула 6-14 не найдена](Images/Frml_6_14.jpg)

Нетрудно заметить, что результатом аффинных преобразований является **AX + B**, что в точности эквивалентно расширению вектора **X** до вектора **X'** и последующего левого умножения на вектор **T**. 

Аффинные преобразования могут быть визуализированы следующим образом: любой параллелограмм ABCD на плоскости может быть отражен в любой другой параллелограмм A'B'C'D'; если площади этих параллелограммов не равны нулю, тогда подразумеваемое афинное преобразование однозначно определено для трех вершин обоих параллелограммов. Так же для понимания аффиннного преобразования можно представить изображение в виде большого резиного листа, который в результате деформации нажатием или растягиванием (вплоть до переворота параллелограмма) за углы может быть преобразован в разнообразные параллелограммы. 

Имея несколько изображений одного объекта с разных ракурсов, можно применить фактическое преобразование для связывания различных ракурсов. В этом случае, зачастую для моделирования ракурсов используются аффинные преобразования, потому что задействуется малое количество параметров, что облегчает процесс вычисления. При этом недостатком является то, что реальные перспективные преобразования могут быть смоделированы только при помощи гомографии ("гомография" - это математический термин для отображения точек одной поверхности к точкам на другой поверхности. В контексте компьютерного зрения, под гомографией почти всегда имеется ввиду отображение между точками двух плоскостей изображений, которые соответствуют расположению объектов на плоскости в реальном мире. Такое преобразование представляется ортогональной матрицей 3x3 (подробнее об этом в главе 11)), так как аффинные преобразования дают представления, которые не могут вместить все возможные связи между ракурсами. С другой стороны, для небольших изменений положения наблюдателя, результирующее искажение будет аффинным, поэтому в некоторых случаях аффинных преобразований вполне достаточно. 

За счет аффинного преобразования прямоугольник может быть преобразован в параллелограмм. При этом, в результате преобразований (вращения и/или масштабирования), стороны должны сохранять параллельность. Перспективные преобразования обеспечивают большую гибкость; прямоугольник может быть преобразован в трапецию. Так как параллелограмм это частный случай трапеции, то и аффинное преобразование это подмножество перспективного преобразования. На рисунке 6-13 представлены примеры различных аффинных и перспективных преобразований.

![Рисунок 6-13 не найден](Images/Pic_6_13.jpg)

Рисунок 6-13. Аффинные и перспективные преобразования

### Аффинные преобразования

Есть две ситуации, при которых используются аффинные преобразования. В первом случае для выполнения преобразования над изображением (или его частью); во втором случае для выполнения преобразования по списку точек.

** Плотные аффинные преобразования **

В первом случае очевидно, что входные и выходные форматы - это изображения, и для преобразования явно требуется, чтобы пиксели были *плотным представлением* нижележащего изображения. Это значит, что преобразователь изображения должен производить интерполяцию, так что конечное изображение будет выглядеть натурально и сглаженно. Функция OpenCV, отвечающая за аффинные преобразования, именуется *cvWarpAffine()*.

```cpp
	void cvWarpAffine(
		 const CvArr* 	src
		,CvArr* 		dst
		,const CvMat* 	map_matrix
		,int 			flags = CV_INTER_LINEAR | CV_WARP_FILL_OUTLIERS
		,CvScalar 		fillval = cvScalarAll(0)
	);
```

Параметры *src* и *dst* указывают на массив или изображение, которые могут быть одно- или трехканальными произвольного типа (при этом оба обязательно одного типа и размера) (Так как вращение изображения приводит к расширению описывающего его прямоугольника, результатом станет отсеченное изображение. Обойти эту проблему можно либо за счет сжатия изображения, либо за счет копирования первого изображения в область интереса ROI целевого изображения большего размера, которое затем используется как исходное изображение для проведения преобразования). Параметр *map_matrix* - это матрица размера 2x3 по которой вычисляется требуемое преобразование. Предпоследний параметр *flags* определяет метод интерполяции, ровно как и следующие вспомогательные опции (комбинирование все возможных значений флага производиться припомощи **OR**).

*CV_WARP_FILL_OUTLIERS* - зачастую, в результате преобразований, изображение *src* не вписывается в изображение *dst*, поэтому на конечное изображение нужно *перенести* пиксели исходного изображения, которых в действительности нет. Если данный флаг выбран, то эти потерянные значения заполняются значением параметра *fillval*.

*CV_WARP_INVERSE_MAP*. Этот флаг предназначен для обратного преобразования *dst* в *src*, вместо стандартного *src* в *dst*.

**Производительность cvWarpAffine**

Важно знать, что использование *cvWarpAffine()* приводит к значительным накладным расходам. Альтернативой является использование *cvGetQuadrangleSubPix()*. Эта функция функционально ограничена, однако, имеет ряд преимуществ. В частности, она имеет меньшие накладные расходы и обрабатывает частный случай, когда исходное изображение 8 битное, а конечное изображение вещественное. Так же эта функция может обрабатывать и многоканальные изображения.

```cpp
	void cvGetQuadrangleSubPix(
		 const CvArr* 	src
		,CvArr* 		dst
		,const CvMat* 	map_matrix
	);
```

*cvGetQuadrangleSubPix()* вычисляет все точки *dst* путем (интерполированного) их отображения из точек *src*, за счет применения афинного преобразования, что в свою очередь подразумевает умножение на матрицу *map_matrix* размером 2x3. (Преобразование расположения пикселей в *dst* к гомогенным координатам для выполнения умножения производиться автоматически)

Особенность *cvGetQuadrangleSubPix()* заключается в том, что функция производит дополнительное отображение. В частности, результат указанный в *dst* вычисляется по следующей формуле: 

![Формула 6-15 не найдена](Images/Frml_6_15.jpg)

где 

![Формула 6-16 не найдена](Images/Frml_6_16.jpg)

Стоит обратить вниманиеб что отображение (x, y) в (x", y") имеет следующий эффект - даже если преобразование M единичное преобразование - точки в центре конечного изображения будут соответствовать точкам, взятым из начала отсчета исходного изображения. Если *cvGetQuadrangleSubPix()* требуется точка вне изображения, будет задействована репликация для восстановления этих значений.

**Вычисление матрицы аффиного преобразования**

OpenCV предоставляет две функции для вычисления матрицы *map_matrix*. Первая используется, когда уже есть два изображения, о которых известно, что они соотносятся неким аффинным преобразованием, либо аппроксимировать их таким образом:

```cpp
	CvMat* cvGetAffineTransform(
		 const CvPoint2D32f* 	pts_src
		,const CvPoint2D32f* 	pts_dst
		,CvMat* 				map_matrix
	);
```

*src* и *dst* - это массивы, содержащие три двухмерные (x, y) точки, а *map_matrix* - вычисляемая из этих точек аффинная матрица. 

Аргументы *pts_src* и *pts_dst* функции *cvGetAffineTransform()* - это всего лишь массивы из трех точек, определяющие два параллелограмма. Простейший способ определить аффинное преобразование - установить указатель *pts_src* на три (вполне достаточно трех точек, т.к. в аффинном преобразовании используется параллелограмм. Четыре точки будут задействованы только в случае с трапецией общего вида в перспективном преобразовании) угла исходного изображения - например, на верхний и нижний левый и на верхний правый. 