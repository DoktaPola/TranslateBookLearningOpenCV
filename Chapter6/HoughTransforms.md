## (П]|(РС)|(РП) Преобразования Хафа

Преобразования Хафа - это метод нахождения линий, кругов и других простых форм на изображении (Хаф разработал данное преобразование для применения в физических эксперементах. Внедрение преобразования для решения задач компьютерного зрения осуществили Duda и Hart). Первоначально преобразование Хафа применялось для нахождения линий, т.к. является относительно быстрым способом нахождения прямых линий на бинарном изображении. В дальнейшем данное преобразование обобщили для более сложных задач, чем поиск линий. 

### Преобразовние Хафа для линий

Теоретической подоплекой преобразования Хафа для линий является то, что любая точка на бинарном изображении, возможно, является частью некоторого множества линий. Если описать каждую линию по её наклону *a* и сдвигу *b* {Roman - наклон и пересечение (или наклон-сдвиг) - параметры уравнения прямой *y = k·x + b*, где *k* - угловой коэффициент прямой, вычисляемый через тангенс, а пересечение *b* - коэфициент сдвига прямой по оси *y* так, чтобы прямая пересекала ось *y* на высоте *b*},то точка на исходном изображении преобразуется во множество точек на плоскости *(a, b)*, соответствующие всем линиям, проходящих через эту точку (рисунок 6-9). Если преобразовать каждый ненулевой пиксель во входном изображении в такой набор точек в выходном изображении и просуммировать все подобные внесения, тогда линия, появившаяся на входном изображении (то есть на плоскости *(x,y)*) будет соответствовать локальному максимуму в выходном изображении (то есть на плоскости *(a,b)*). Поскольку суммируется вклад от каждой точки, плоскость *(a,b)* принято называть накопительной плоскостью. 

Может оказаться, что плоскость вида наклон-сдвиг не лучший способ представления всех линий, проходящих через точку (из-за значительно различной плотности линий в зависимости от наклона, и того, что интервал возможных наклонов лежит в диапазоне от –∞ до +∞) {Roman - бесконечности из-за того, что наклон расчитывается через тангенс}. По этой причине, в численных расчетах используется другая параметризация изображения преобразования. Предпочтительная параметризация представляет каждую линию как точку в полярных координатах (*ρ*, *θ*), при чем эта линия проходит через указанную точку, но линия должна быть перпендикулярной к радиус-вектору от начала координат до этой точки на линии (рисунок 6-10). Уравнение для такой прямой: 

*ρ* = *x*cos*θ* + *y*sin*θ*

![Рисунок 6-9 не найден](Images/Pic_6_9.jpg)

Рисунок 6-9. Преобразование Хафа для линий находит множество линий на каждом изображении. Некоторые из них ожидаемые, но другие могут не быть таковыми

![Рисунок 6-10 не найден](Images/Pic_6_10.jpg)

Рисунок 6-10. Точка (![Формула 6-12 не найдена](Images/Pic_6_12.jpg), ![Формула 6-13 не найдена](Images/Frml_6_13.jpg)) на плоскости изображения (график *a*) соответствует множеству линий, каждая из которых параметризирована разными *ρ* и *θ* (график *b*); каждая из этих линий соответствует точкам на плоскости (*ρ*, *θ*), которые, будучи собранными вместе, образуют кривую характеристической формы (график *c*)

Алгоритм преобразования Хафа не являются явными для пользователя. Вместо этого он просто возвращает локальный максимум на плоскости (*ρ*, *θ*). Однако, необходимо понимать процесс преобразования, что бы осознавать назначения входных аргументов для функции, выполняющей преобразования Хафа для линий.

OpenCV поддерживает два вида преобразований Хафа для линий: *обычное преобразование Хафа* (SHT) и *прогрессивное (улучшенное) вероятностное преобразование Хафа* (PPHT). Ранее уже был рассмотрен алгоритм SHT. PPHT является его разновидностью и также вычисляет протяжонность каждой линии в дополнение к их наклону (рисунок 6-11). Алгоритм назван "вероятностным", т.к. вместо добавления каждой возможной точки на накопительную плоскость, он добавляет только часть из них. Идея состоит в том, что если существует максимум на плоскости, то, в любом случае, хотя бы частичное попадание в этот максимум будет достаточным условием, чтобы его обнаружить; как результат - существенное снижение времени выполнения вычислений. Для обоих случаев в OpenCV существует одна функция, которая, в зависимости от входных параметров, принимает решение о выполнение того или иного метода. 

```cpp
	CvSeq* cvHoughLines2(
		 CvArr* 	image
		,void* 		line_storage
		,int 		method
		,double 	rho
		,double 	theta
		,int 		threshold
		,double 	param1 = 0
		,double 	param2 = 0
	);
```

Первый аргумент - это исходное изображение. Оно должно быть 8-битным, но при этом будет трактоваться как бинарное (т.е. все ненулевые значения будут восприниматься как равные единицы). Второй аргумент - указатель на место, где будет храниться результат, который может быть либо хранилищем в памяти (*CvMemoryStorage* из главы 8) или либо матрицей размера *Nx1* (при этом количество строк *N* будет также еще ограничивать максимальное число возвращаемых линий). Следующий аргумент *method* может быть *CV_HOUGH_STANDARD*, *CV_HOUGH_PROBABLISTIC*, *CV_HOUGH_MULTI_SCALE* для SHT, PPHT и многопараметрического варианта SHT (MSHT) соответственно. 

Следующие два аргумента, *rha* и *theta*, устанавливают желательное разрешение для линий (т.е. разрешение накопительной плоскости). Параметр *rho* вычисляется в пикселях, а параметр *theta* в радианах, поэтому накопительную плоскость можно рассматривать как двухмерную гистограмму с ячейками размерностью *rho* пикселей на *theta* радиан. Значение параметра *threshold* определяет величину, при достижении которой сообщается о нахождении линии. Этот последний параметр на практике несколько мудрёный, при чем он не нормализуется, поэтому ожидается, что сам разработчик будет его масштабировать с учетом роста размерности входного изображения для алгоритма SHT. Помните, этот параметр, в действительности, определяет количество точек, которые должны поддерживать линию, чтобы линия была добавлена в возвращаемый список линий. 

![Рисунок 6-11 не найден](Images/Pic_6_11.jpg)

Рисунок 6-11. Сначала выполнен проход при помощи детектора границ *Canny* (*param1 = 50*, *param2 = 150*), результат показан в оттенках серого. Затем произведено прогрессивное вероятностное преобразование Хафа (*param1 = 50*, *param2 = 10*), результат показан белым. Заметьте, что преобразование Хафа в основном правильно обнаруживает чёткие линии

Аргументы *param1* и *param2* алгоритм SHT не использует. Для алгоритма PPHT *param1* задает минимальную длину для возвращаемого сегмента линии, а аргумент *param2* задает расстояние между коллинеарными сегментами, необходимое для того, чтобы алгоритм не склеил их вместе в один сегмент большей длины. Для многопараметрического варианта SHT эти два параметра применяются для указания наивысшего разрешения до которого параметры возвращаемых линий должны быть вычислены. Многопараметрический SHT сначала вычисляет положение линий с учетом разрешений *rho* и *theta*, а затем начинает уточнение результатов до степени параметров *param1* и *param2* соответственно (т.е. конечное разрешение *rho* – это rho делённое на *param1*, а конечное разрешение для *theta* равно *theta* делённому на *param2*). 

Возвращаемое значение функции зависит от входных параметров. Если параметр *line_storage* матрица, тогда возвращаемое значение будет NULL. В этом случае, матрица должна быть типа *CV_32FC2* для SHT или многопараметрического SHT и *CV_32SC4* для PPHT. В первых двух случаях величины *ρ* и *θ* для каждой линии будут помещены в двух каналах массива. В случае PPHT, черыте канала будут содержать значения *x* и *y* для начальной и конечной точек возвращаемого сегмента. И для всех этих случаев, количество строк в массиве будет обновлено функцией *cvHoughLines2()* до количества возвращаемых линий. 

Если параметр *line_storage* содержит указатель на хранилище в памяти (более подробно об этом будет рассказано в главе 8), тогда возвращаемым значением будет указатель на структуру последовательности *CvSeq*. В этом случае, можно получить каждую линию или сегмент линии из последовательности при помощи подобной команды:

```cpp
	float* line = (float*) cvGetSeqElem( lines, i );
```

где *lines* это возвращаемое значение функции *cvHoughLines2()*, а *i* - индекс запрашиваемой линии. В этом случае, *line* будет указателем на данные этой линии, при чем *line[0]* и *line[1]* будут действительными числами, соответствующие значениям *ρ* и *θ* (для SHT и MSHT), либо указателем на структуру из парных значений *CvPoint* для начальной и конечной точек сегмента (для алгоритма PPHT). 

### Преобразование Хафа для окружностей

Преобразование Хафа для окружностей (рисунок 6-12) работает почти аналогично только что описанному преобразованию Хафа для линий. "Почти" только лишь потому, что - если выполнить точно аналогичные действия - накопительная плоскость будет замещена плоскостью объема с тремя измерениями: одно для *x*, одно для *y* и последнее для радиуса круга *r*. Это приводит к значительно большим затратам памяти и значительно меньшей скорости выполнения. Реализация преобразования Хафа для окружности в OpenCV уходит от этой проблемы, применяя несколько хитрый метод, называемый градиентым методом Хафа.

Градиентный метод Хафа работает следующим образом. Вначале изображение проходит фазу поиска краев (использование функции *cvCanny()*). Затем для каждой ненулевой точки краев изображения ищется локальный градиент (вычисляется путем расчета производных Собеля первого и второго порядка для *x* и *y* при помощи функции *cvsobel()*). Используя этот градиент, каждая точка линии обозначается как наклон - от установленного минимума до указанного максимального расстояния - итерационно изменяя накопитель. В тоже время, запоминается расположение каждой ненулевой точки на изображении краев. Центры-кандидаты затем выбираются из тех точек (двухмерного) накопителя, величины которых выше заданного порога и, одновременно, больше всех их непосредственных соседей. Эти центры-кандидаты сортируются в порядке убывания их величины в накопителе, так, что центры с наибольшим количеством пикселей выбираются первыми. Далее, для каждого центра, анализируются все ненулевые пиксели. Эти пиксели упарядочиваются в соответствии с их расстоянием от центра. Обрабатывая от наименьших расстояний до наибольших радиусов, выбирается единственный радиус, который лучше всего подходит ненулевым пикселям. Центр сохраняется, если он имеет достаточное количество ненулевых пикселей на краевом изображении и если расстояние от любого ранее выбранного центра удовлетворяет заданному значению. 

