## (П]|(РС)|(РП) Преобразования Хафа

Преобразования Хафа - это метод нахождения линий, кругов и других простых форм на изображении (Хаф разработал данное преобразование для применения в физических эксперементах. Внедрение преобразования для решения задач компьютерного зрения осуществили Duda и Hart). Первоначально преобразование Хафа применялось для нахождения линий, т.к. является относительно быстрым способом нахождения прямых линий на бинарном изображении. В дальнейшем данное преобразование обобщили для более сложных задач, чем поиск линий. 

### Преобразовние Хафа для линий

Теоретической подоплекой преобразования Хафа для линий является то, что любая точка на бинарном изображении, возможно, является частью некоторого множества линий. Если описать каждую линию по её наклону *a* и сдвигу *b*{Roman - наклон и пересечение (или наклон-сдвиг) - параметры уравнения прямой *y = k·x + b*, где *k* - угловой коэффициент прямой, вычисляемый через тангенс, а пересечение *b* - коэфициент сдвига прямой по оси *y* так, чтобы прямая пересекала ось *y* на высоте *b*},то точка на исходном изображении преобразуется во множество точек на плоскости *(a, b)*, соответствующие всем линиям, проходящих через эту точку (рисунок 6-9). Если преобразовать каждый ненулевой пиксель во входном изображении в такой набор точек в выходном изображении и просуммировать все подобные внесения, тогда линия, появившаяся на входном изображении (то есть на плоскости *(x,y)*) будет соответствовать локальному максимуму в выходном изображении (то есть на плоскости *(a,b)*). Поскольку суммируется вклад от каждой точки, плоскость *(a,b)* принято называть накопительной плоскостью. 

Может оказаться, что плоскость вида наклон-сдвиг не лучший способ представления всех линий, проходящих через точку (из-за значительно различной плотности линий в зависимости от наклона, и того, что интервал возможных наклонов лежит в диапазоне от –∞ до +∞) {Roman - бесконечности из-за того, что наклон расчитывается через тангенс}. По этой причине, в численных расчетах используется другая параметризация изображения преобразования. Предпочтительная параметризация представляет каждую линию как точку в полярных координатах (*ρ*, *θ*), при чем эта линия проходит через указанную точку, но линия должна быть перпендикулярной к радиус-вектору от начала координат до этой точки на линии (рисунок 6-10). Уравнение для такой прямой: 

*ρ* = *x*cos*θ* + *y*sin*θ*

![Рисунок 6-9 не найден](Images/Pic_6_9.jpg)

Рисунок 6-9. Преобразование Хафа для линий находит множество линий на каждом изображении. Некоторые из них ожидаемые, но другие могут не быть таковыми

![Рисунок 6-10 не найден](Images/Pic_6_10.jpg)

Рисунок 6-10. Точка (![Формула 6-12 не найдена](Images/Pic_6_12.jpg), ![Формула 6-13 не найдена](Images/Frml_6_13.jpg)) на плоскости изображения (график *a*) соответствует множеству линий, каждая из которых параметризирована разными *ρ* и *θ* (график *b*); каждая из этих линий соответствует точкам на плоскости (*ρ*, *θ*), которые, будучи собранными вместе, образуют кривую характеристической формы (график *c*)

Алгоритм преобразования Хафа не являются явными для пользователя. Вместо этого он просто возвращает локальный максимум на плоскости (*ρ*, *θ*). Однако, необходимо понимать процесс преобразования, что бы осознавать назначения входных аргументов для функции, выполняющей преобразования Хафа для линий.

OpenCV поддерживает два вида преобразований Хафа для линий: *обычное преобразование Хафа* (SHT) и *прогрессивное (улучшенное) вероятностное преобразование Хафа* (PPHT). Ранее уже был рассмотрен алгоритм SHT. PPHT является его разновидностью и также вычисляет протяжонность каждой линии в дополнение к их наклону (рисунок 6-11). Алгоритм назван "вероятностным", т.к. вместо добавления каждой возможной точки на накопительную плоскость, он добавляет только часть из них. Идея состоит в том, что если существует максимум на плоскости, то, в любом случае, хотя бы частичное попадание в этот максимум будет достаточным условием, чтобы его обнаружить; как результат - существенное снижение времени выполнения вычислений. Для обоих случаев в OpenCV существует одна функция, которая, в зависимости от входных параметров, принимает решение о выполнение того или иного метода. 

```cpp
	CvSeq* cvHoughLines2(
		 CvArr* 	image
		,void* 		line_storage
		,int 		method
		,double 	rho
		,double 	theta
		,int 		threshold
		,double 	param1 = 0
		,double 	param2 = 0
	);
```

Первый аргумент - это исходное изображение. Оно должно быть 8-битным, но при этом будет трактоваться как бинарное (т.е. все ненулевые значения будут восприниматься как равные единицы). Второй аргумент - указатель на место, где будет храниться результат, который может быть либо хранилищем в памяти (*CvMemoryStorage* из главы 8) или либо матрицей размера *Nx1* (при этом количество строк *N* будет также еще ограничивать максимальное число возвращаемых линий). Следующий аргумент *method* может быть *CV_HOUGH_STANDARD*, *CV_HOUGH_PROBABLISTIC*, *CV_HOUGH_MULTI_SCALE* для SHT, PPHT и многопараметрического варианта SHT (MSHT) соответственно. 

Следующие два аргумента, *rha* и *theta*, устанавливают желательное разрешение для линий (т.е. разрешение накопительной плоскости). Параметр *rho* вычисляется в пикселях, а параметр *theta* в радианах, поэтому накопительную плоскость можно рассматривать как двухмерную гистограмму с ячейками размерностью *rho* пикселей на *theta* радиан. Значение параметра *threshold* определяет величину, при достижении которой сообщается о нахождении линии. Этот последний параметр на практике несколько мудрёный, при чем он не нормализуется, поэтому ожидается, что сам разработчик будет его масштабировать с учетом роста размерности входного изображения для алгоритма SHT. Помните, этот параметр, в действительности, определяет количество точек, которые должны поддерживать линию, чтобы линия была добавлена в возвращаемый список линий. 

![Рисунок 6-11 не найден](Images/Pic_6_11.jpg)

Рисунок 6-11. Сначала выполнен проход при помощи детектора границ *Canny* (*param1 = 50*, *param2 = 150*), результат показан в оттенках серого. Затем произведено прогрессивное вероятностное преобразование Хафа (*param1 = 50*, *param2 = 10*), результат показан белым. Заметьте, что преобразование Хафа в основном правильно обнаруживает чёткие линии

