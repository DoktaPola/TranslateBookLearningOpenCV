## (П]|(РС)|(РП) Универсальные методы библиотеки ML

Эта глава содержит описание того, как работают алгоритмы машинного обучения. Будут рассмотрены удобные универсальные методы, описание которых так же можно найти в документации (.../opencv/docs/ref/opencvref_ml.htm), устанавливаемой вместе с OpenCV и/или в онлайн документации OpenCV Wiki (http://opencvlibrary.sourceforge.net). Данная подбиблиотека на момент написания книги находилась в активной разработке.

Все методы библиотеки ML (алгоритмы Haar classifier, Mahalanobis и K-means были реализованы до появления библиотеки ML и потому находятся в библиотеках *cv* и *cvcore*) написаны как классы C++, наследующиеся от класса *CvStatModel*, содержащий универсальные методы для всех алгоритмов. Эти методы перечислены в таблице 13-3. Стоит обратить внимание на то, что в *CvStatModel* реализованы две модели сохранения и загрузки данных: *save()* и *write()* для сохранения; load() и read() для загрузки. Для моделей машинного обучения необходимо использовтаь более простые *save()* и *load()*, которые по существу являются обертками более сложных функций *write()* и *read()* интерфейса, который записывает и читает XML и YAML на и с диска. Реализация двух других наиболее важных функций, *predict()* и *train()*, зависит от алгоритма и будет рассматриваться далее.

Таблица 13-3. Методы базового класса библиотеки ML

| **CvStatModel::Methods** | **Описание** |
| -- | -- |
| save( const char* filename, const char* name = 0 ) | Сохранение обученной модели в XML или YMAL. Метод используется для сохранения |
| load( const char* filename, const char* name = 0 ) | Вызов *clear()* с последующей загрузкой XML или YMAL модели. Метод используется для загрузки |
| clear() | Освобождение всей занимаемой памяти. Возможно повторное использование |
| bool train( —data points—, [flags] —responses—, [flags etc] ) | Функция обучения модели данных. Обучение специфично для каждого алгоритма и потому входные параметры разичны |
| float predict( const CvMat* sample [,<prediction_params>] ) const | Функция используется после обучения дял предсказания метки или значения новой обучаемой точки иил точек |
| **Конструктор, Деструктор** |  |
| CvStatModel(); CvStatModel( const CvMat* train_data ... ); | Конструктор по умолчанию и конструктор, позволяющий создавать и обучать модель в одном кадре |
| CvStatModel::~CvStatModel(); | Деструктор |
| Поддерживаемые Write/Read (использовать save/load) |  |
| write( CvFileStorage* storage, const char* name ) | CvFileStorage - общая структура записи на диск (обсуждалась в главе 3), расположенная в библиотеке *cvcore*. Вызывается из *save()* |
| read( CvFileStorage* storage, CvFileNode* node ) | CvFileStorage - общая структура записи на диск (обсуждалась в главе 3), расположенная в библиотеке *cvcore*. Вызывается из *load()* |

### Обучение

Прототип метода обучения:

```cpp
	bool CvStatModel::train(
		const CvMat*  train_data,
		[int tflag,] 				...,
		const CvMat*  responses, 	...,
		[const CvMat* var_idx,] 	...,
		[const CvMat* sample_idx,] 	...,
		[const CvMat* var_type,] 	...,
		[const CvMat* missing_mask,]
		<misc_training_alg_params> 	...
	);
```

Метод *train()* может принимать различные формы в зависимости от используемого алгоритма. Все алгоритмы принимают в качестве входных данных (для обучения) указатель на матрицу типа CvMat. Эта матрица должна быть типа 32FC1 (32-битной, вещественной, одноканальной). CvMat можно использовать и для многоканальных изображений, но алгоритмы машинного обучения могут работать только с одним каналом - т.е. только с дмумерной матрицей чисел. Как правило, эта матрица организована в виде строк точек, где каждая "точка" представлена как ветор особенностей. Следовательно, столбцы содержат конкретные особенности для каждой точки, а все вместе точки образуют двумерную одноканальную матрицу для обучения. Таким образом типичная матрица данных состоит из (строка, столбец) = (точки, особенности). Вместе с тем некоторые алгоритмы могут обрабатывать транспанированную (ранее обсуждаемую) матрицу. Для таких алгоритмов можно использовать параметр *tflag*, чтобы сообщить алгоритму о том, что точки находятся в столбцах, а не в строках. Это удобно, т.к. ненужно самостоятельно выполнять транспониование. Когда алгоритм может обрабатывать данные, представленные обоими способавми, необходимо использовать следующие флаги:

*tflag = CV_ROW_SAMPLE*

Это значит, что вектор особенностей хранится в строке (по умолчанию)

*tflag = CV_COL_SAMPLE*

Это значит, что вектор особенностей храниться в столбце

Может возникнуть вопрос: а что, если обучающий набор данных представлен не вещественными числами, а буквами алфавита или целыми числами, представляющие музыкальные ноты или названия растений? Ответ следующий: просто используйте 32-битные вещественные числа при заполнении *CvMat*. В случае с буквами, особенности или метки ASCII символов можно расценивать как вещественные числа при заполнении массива данных. Тоже самое относится и к целым числам. До тех пор, пока переход уникален, всё работает - однако, не стоит забывать, что некоторые методы чувствительны к широким различиям дисперсии между особенностями. В большинстве случаев, лучше нормализовать дисперсию особенностей, как было описано ранее. Лишь за исключением алгоритмов, основанных на деревьях (decision trees, random trees и boosting), которые поддерживают и недвусмысленные и упорядоченные входные переменные; все остальные алгоритмы OpenCV ML работают только с упорядоченными входами. Популярный метод создания упорядоченного входа для алгоритма также работает и с недвусмысленными данными, чтобы представить их в единичной системе счисления; например, если входная переменная цвета может иметь семь различных значений, то она может быть заменена на семь двоичных переменных, где одна и только одна из переменных может быть установлена в 1. 