## [П)|(РС)|(РП) Упражнения

1. Загрузите любое изображение и размойте его с помощью *cvSmooth()* с *smoothtype = CV_GAUSSIAN*.
	
	a. Используйте симметричную область сглаживания 3x3, 5x5, 9x9, 11x11 и выведите результаты на экран. 

	b. Одинаковы ли результаты двойного сглаживания изображения с областью 5x5 и с областью 11x11. Почему да или почему нет?

2. Создайте одноканальное изображение 100x100, очистите его и установите центральный пиксель равный 255.

	a. Размойте данное изображение с помощью Гауссова ядра размером 5x5 и отобразите результат. 

	b. Сделайте тоже самое с фильтром 9x9.

	c. Что будет, если исходное изображение сгладить дважды фильтром 5x5? Сравните этот результат с результатом сглаживания с использованием фильтра 9x9. Являются ли они почти одинаковыми? Почему да или почему нет?

3. Загрузите любое изображение и размойте его с помощью *cvSmooth()*. 

	a. Установите *param1 = param2 = 9*, и попробуйте изменять значение *param3* (например 1, 4, 6). Отобразите результат в трех разных окнах.

	b. Теперь установите *param1 = param2 = 9*, и попробуйте изменять значение *param3* (1, 4, 6). Отобразите результат в трех разных окнах. Отличаются ли они? Почему?

	c. Опять установите *param1 = param2 = 0*, только теперь *param3 = 1*, а *param4 = 9*. Отобразите результат.

	d. Опять установите *param1 = param2 = 0*, только теперь *param3 = 9*, а *param4 = 1*. Отобразите результат.

	e. Теперь последовательно примените операцию сглаживания сначала с настройками из пункта c, а затем с настройками из пункта d. Отобразите результат.

	f. Сравните результаты операции сглаживания из пункта e, при условии, что *param3 = param4 = 9* и *param3 = param4 = 0*. Результаты теже? Почему да или почему нет?

4. Используя камеру, сделайте две фоторгафии одной и той же сцены, стараясь не двигать камеру. Загрузите эти изображения как *src1* и *src2*.

	a. Вычислите абсолютное значение *src1 - src2* (вычитание изображений), сохраните результат в *diff12* и отобразите результат. Если все было сделато верно, то изображение *diff12* будет состоять из пикселей только черного цвета. Почему это так?

	b. Создайте *cleandiff* с помощью *cvErode()*, а затем примените *cvDilate()* к *diff12*, отобразите результат. 

	c. Создайте *dirtydiff* с помощью *cvDilate()*, а затем примените *cvErode()* к *diff12*, отобразите результат.

	d. Объясните разницу между *cleandiff* и *dirtydiff*. 

5. Сделайте изображение любой сцены. Затем, не перемещая камеру, поставте какой-нибудь предмет и сделайте второй снимок. Загрузите эти изображения и конвертируйте в 8-битные в градациях серого изображения.

	a. Вычислите абсолютное значение их разности (*cvAbsDiff()*). Выведите результат, который должен содержать зашумленную маску предмета.

	b. Выполните двоичное пороговое преобразование в результате которого предмет остается, но некоторая степень шума удаляется. Отобразите результат. 

	c. Выполните *CV_MOP_OPEN* над изображением, чтобы ещё больше устранить шум. 

6. Создание маски, очищенной от шума. После выполнения упражнения 5, необходимо найти самый большой регион на изображении. Установите указатель в верхнем левом углу изображения и пройдитесь по всему изображению. Когда будут встречаться значения 255, используйте функцию *cvFloodFill()* со значением 100 в этой точке. Извлеките связную компоненту, которую вернет функция и сохраните её. Найдите самую большю область и залейте её значением 255. Если последующая область больше предыдущей, то предыдущую залейте 0, а текущую значением 255. И так до тех пор, пока не останется самая большая область. Отобразите результат. В результате должна получиться довольно таки точная маска объекта.

7. Для выполнения этого упражнения используйте маску из предыдущего упражнения или создайте другую маску (например, просто маска в виде квадрата). Создайте новое изображение сцены и поместите в него, с помощью функции *cvCopy()*, маску объекта. 

8. Создайте низко дисперстное случайное изображение (используйте случайно генерируемое число из диапазона от 0 до 3). Загрузите полученное изображение в любой графический редактор и нарисуйте на нем множество линий, сходящихся в одной точке. В завершение примените двухстороннюю фильтрацию на полученном изображении и объясните полученный результат. 

9. Загрузите изображении сцены в градациях серого

	a. Выполните морфологическую операцию Top Hat на изображении сцены и отобразите результат.

	b. Конвертируйте полученное изображение в 8-битное

	c. Скопируйте значения в оттенках серого в части Top Hat и отобразите результат.

10. загрузите изображение с множеством объектов.

	a. Используя функцию *cvResize()* уменьшите изображение в 2 раза по каждому измерению (следовательно изображение будет уменьшено в 4 раза). Проделайте это еще три раза и отобразите результат. 

	b. Теперь возьмите оригинальное изображение и, используя функцию *cvPyrDown()*, уменьшите его трижды и отобразите реультат.

	c. В чем различия между результатами из пункта a и b? 

11. Загрузите изображение сцены. Примените к изображению функцию *cvPyrSegmentation()* и отобразите результат.

12. Загрузите изображение с достаточно "богатой" сценой. Примените к изображению функцию *cvThreshold()* с порогом 128. Воспользуйтесь всеми параметрами из таблицы 5-5 и отобразите результаты. Осознание принципов работы порогового преобразования принесет еще не мало пользы в дальнейшем.

	a. Повторите упражнение но уже с использованием функции *cvAdaptiveThreshold()*. Установите *param1 = 5*.

	b. Повторите предыдущий пункт, используя сначала параметр *param1 = 0*, а затем к результату вновь применить функцию *cvAdaptiveThreshold()*, но уже с параметром *param1 = -5*.