## [П]|[РС]|(РП) Отображение изображения

*cvShowImage()* - функция, при помощи которой можно отобразить изображение в ранее созданном окне: 

```cpp
void cvShowImage(
     const char*    name
    ,const CvArr*   image
);
```

Первый аргумент - имя окна, в котором отображается изображение, второй - указатель на изображение. 

Рассмотрим небольшой пример программы, которая отображает изображение на экране. Вся программа занимает всего 22 строки, включая загрузку изображения, комментарии и очистку памяти.

```cpp
int main( int argc, char** argv ) {
	// Создание окна с таким же именем, как и у загружаемого файла изображения
	// 
	cvNamedWindow( argv[1], 1 );

	// Загрузка изображения
	// 
	IplImage* img = cvLoadImage( argv[1] );
	
	// Отображение изображения
	// 
	cvShowImage( argv[1], img );
	
	// Ожидание нажатия клавиши "Esc"
	// 
	while( 1 ) {
		if( 27 == cvWaitKey( 100 ) ) break;
	}

	// Очистка памяти
	// 
	cvDestroyWindow( argv[1] );
	cvReleaseImage( &img );
	
	exit(0);
}
```

Для более удобного восприятия результата, получаемого в результате выполнения программы, окну присвоено имя загружаемого файла изображения (рисунок 4-1).

![Рисунок 4-1 не найден](Images/Pic_4_1.jpg)

Рисунок 4-1. Отображение изображения при помощи функции *cvShowImage()*

Прежде, чем двигаться дальше, рассмотрим ещё несколько функций для работы с окнами:

```cpp
void cvMoveWindow( const char* name, int x, int y );
void cvDestroyAllWindows( void );
int cvStartWindowThread( void );
```

*cvMoveWindow()* перемещает окно таким образом, чтобы его верхний левый угол располагался в точке *x*, *y*.

*cvDestroyAllWindows()* очень полезная функция, которая закрывает все окна и очищает всю занимаемую ими память. 

В Linux и MacOS имеется функция *cvStartWindowThread()*, создающая поток, который автоматически обновляет все связанные с окном события. Функция возвращает 0, если не получается запустить ни одного потока; например, при отсутствии поддержки данной функции в используемой версии OpenCV. Если не создавать окно в отдельном потоке, тогда OpenCV сможет реагировать на действия пользователя только в определенные моменты времени (например, когда вызывается функция *cvWaitKey()*).


### WaitKey

Функция *cvWaitKey()* заставляет программу ожидать определенное количество миллисекунд, позволяя тем самым пользователю нажать любую клавишу. Если в течении отведенного времени клавиша будет нажата, то функция вернет код нажатой клавиши, иначе вернет 0. 

```cpp
while( 1 ) {
	if( 27 == cvWaitKey(100) ) break;
}
```

Функция *cvWaitKey()* ожидает нажатия клавиши 100 мс. Если ASCII код нажатой клавиши равен 27 (клавиша *Esc*), то выполнение цикла прекратиться. Данной подход позволяет задержать показ окна, пока не будет нажата клавиша *Esc*. 

Если в качестве аргумента функции *cvWaitKey()* передать 0, то ожидание будет продолжаться неопределенное количество времени, до момента нажатия любой клавиши. В предыдущем примере можно было бы использовать и *cvWaitKey(0)*. Разница между этими двумя вариантами становится более очевидной при обработки видео.


### События мыши

Теперь, когда уже есть знания по загрузке и отображению изображения, а также обработке событий от клавиш клавиатуры, можно перейти к обработке событий мыши.

В отличии от событий клавиатуры, события от мыши обрабатываются более типичным образом - при помощи механизма обратного вызова. Это означает, что необходимо писать функции обратного вызова, чтобы обработать щелчки мыши. Функция обратного вызова подлежит регистрации в OpenCV, тем самым информируя OpenCV, что данная функция обрабатывает события мыши над конкретным окном.

Функцией обратного вызова может быть любая функция, которая принимает правильный набор аргументов и возвращает правильный тип. Подобного рода функции должны определять что за мероприятие и где произошло. так же эти функции должны определять нажатие клавиш Shift и Alt в сочетании с нажатиями клавиш мыши. Точный прототип функции обратного вызова выглядит следующим образом:

```cpp
void CvMouseCallback(
     int    event
    ,int    x
    ,int    y
    ,int    flags
    ,void*  param
);
```

При вызове данной функции OpenCV будет заполнять аргументы соответствующими значениями. Первый аргумент *event* (событие) будет иметь одно из значений, указанных в таблице 4-1.

Таблица 4-1. Типы событий мыши

| Событие | Числовое значение |
| -- | -- |
| CV_EVENT_MOUSEMOVE | 0 |
| CV_EVENT_LBUTTONDOWN | 1 |
| CV_EVENT_RBUTTONDOWN | 2 |
| CV_EVENT_MBUTTONDOWN | 3 |
| CV_EVENT_LBUTTONUP | 4 |
| CV_EVENT_RBUTTONUP | 5 |
| CV_EVENT_MBUTTONUP | 6 |
| CV_EVENT_LBUTTONDBLCLK | 7 |
| CV_EVENT_RBUTTONDBLCLK | 8 |
| CV_EVENT_MBUTTONDBLCLK | 9 |

Второй и третий аргументы устанавливают координаты места события мыши. Стоит отметить, что эти координаты представляют собой пиксель на изображение независимо от размера окна.

Четвертый аргумент *flags* - это битовое поле, в котором отдельные биты указывают на особые условия, присутствующие на момент события. Например, флаг *CV_EVENT_FLAG_SHIFTKEY*, имеющий числовое значение 16 (т.е. 5 бит), проверяет нажатие *shift*. Можно использовать сочетание нескольких флагов при помощи операции *AND*. Полный список флагов представлен в таблице 4-2.

Таблица 4-2. Флаги для событий мыши

| Флаг | Числовое значение |
| -- | -- |
| CV_EVENT_FLAG_LBUTTON | 1 |
| CV_EVENT_FLAG_RBUTTON | 2 |
| CV_EVENT_FLAG_MBUTTON | 4 |
| CV_EVENT_FLAG_CTRLKEY | 8 |
| CV_EVENT_FLAG_SHIFTKEY | 16 |
| CV_EVENT_FLAG_ALTKEY | 32 |

Последний аргумент - это указатель *void*\*, который может быть использован для передачи дополнительной информации в виде указателя на необходимую структуру. В общем случае, параметр *param* используется, когда функция обратного вызова является статическим членом класса. 

Для регистрации функции обратного вызова используется функция *cvSetMouseCallback()*:

```cpp
void cvSetMouseCallback(
     const char*        window_name
    ,CvMouseCallback    on_mouse
    ,void*              param = NULL
);
```

Первый аргумент — это имя окна, к которому будет прикреплена функция обратного вызова. Соответственно данная функция обратного вызова будет отслеживать только события, связанные с этим окном. Вторым аргументом является функция обратного вызова. Третий аргумент позволяет указывать дополнительную информацию. Это тот самый *param*, о котором ранее шла речь. 

В примере 4-1 описана небольшая программа рисования прямоугольника при помощи мыши. Функция *my_mouse_callback()* реагирует на события мыши и определяет дальнейшии действия.

Пример 4-1. Игрушечная программа, использующая мышь для рисования прямоугольника

```cpp
#include <cv.h>
#include <highgui.h>

// Объявление прототипа функции обратного вызова для реагирования
// на события мыши
// 
void my_mouse_callback( int event, int x, int y, int flags, void* param );

CvRect  box;
bool    drawing_box = false;

// Функция рисования прямоугольника на изображении
// 
void draw_box( IplImage* img, CvRect rect ) {
    cvRectangle (
         img
        ,cvPoint(box.x,box.y)
        ,cvPoint(box.x+box.width,box.y+box.height)
        ,cvScalar(0xff,0x00,0x00) /* red */
    );
}

int main( int argc, char* argv[] ) {
    box = cvRect( -1, -1, 0, 0 );
    IplImage* image = cvCreateImage(
         cvSize( 200, 200 )
        ,IPL_DEPTH_8U
        ,3
    );

    cvZero( image );
    IplImage* temp = cvCloneImage( image );
    cvNamedWindow( "Box Example" );

    // Регистрация функции обратного вызова
    // В качестве значения "param" передается изображение, 
    // которое функция обратного вызова будет обрабатывать
    // 
    cvSetMouseCallback(
         "Box Example"
        ,my_mouse_callback
        ,(void*) image
    );

    // Главный цикл. Сначала происходит копирование оригинального изображения
    // во временное "temp" изображение, и если пользователь рисует, тогда
    // прямоугольник помещается на временное изображение, в заключении результат действий
    // отображается на экране. Если после ожидания 15 мс не будет нажата необходимая для 
    // выхода из цикла клавиша, происходит переход к следующей итерации
    // 
    while( 1 ) {
        cvCopyImage( image, temp );
        
        if( drawing_box ) { 
            draw_box( temp, box );
        }
        
        cvShowImage( "Box Example", temp );
        
        if( 27 == cvWaitKey( 15 ) ) {
            break;
        }
    }

    // Освобождение занимаемой памяти
    // 
    cvReleaseImage( &image );
    cvReleaseImage( &temp );
    cvDestroyWindow( "Box Example" );
}

// Функция обратного вызова. Если пользователь нажмет левую клавишу
// мыши, активизируется функция рисования. Когда пользователь отпускает 
// эту клавишу, происходит добавление прямоугольника на текущее изображение.
// При перемещении мыши происходит изменение размеров прямоугольника
// 
void my_mouse_callback( int event, int x, int y, int flags, void* param ) {
    IplImage* image = (IplImage*) param;
    switch( event ) {
        case CV_EVENT_MOUSEMOVE: {
            if( drawing_box ) {
                box.width = x-box.x;
                box.height = y-box.y;
            }
        }
        break;
        case CV_EVENT_LBUTTONDOWN: {
            drawing_box = true;
            box = cvRect(x, y, 0, 0);
        }
        break;
        case CV_EVENT_LBUTTONUP: {
            drawing_box = false;

            if(box.width<0) {
                box.x+=box.width;
                box.width *=-1;
            }

            if(box.height<0) {
                box.y+=box.height;
                box.height*=-1;
            }

            draw_box(image, box);
        }
        break;
    }
}
```


### Sliders, Trackbars и Switches

В HighGUI ползунок именуется trackbar-ом. Это все потому, что в оригинальной (исторической) трактовке данный элемент использовался для выбора конкретного кадра из видеопотока. При помощи данного элемента можно делать как привычные вещи, связанные с ползунком, так и более необычные (будут рассмотрены в следующем разделе "No Buttons"). 

Как и в случае с окном, слайдер имеет уникальное имя (символьная строка), благодаря которому со слайдером можно производить различные манипуляции. Прототип функции создания слайдера:

```cpp
int cvCreateTrackbar(
     const char*        trackbar_name
    ,const char*        window_name
    ,int*               value
    ,int                count
    ,CvTrackbarCallback on_change
);
```

Первые два аргумента задают имя слайдера и имя окна, к которому будет прикреплен создаваемый слайдер. После создания, слайдер будет добавлен в верхнюю или нижнюю часть окна; при этом он не будет перекрывать ранее добавленное изображение.

Следующие два аргумента: *value* - целочисленный указатель, указывающий позицию ползунка, *count* - максимальное значение ползунка. 

Последний аргумент указывает на функцию обратного вызова, которая автоматически вызывается при перемещении ползунка. Прототип функции обратного вызова:

```cpp
void (*callback)( int position )
```

Если функция обратного вызова не требуется, то необходимо передать NULL. В этом случае эффект от использования ползунка заключается в перемещении ползунка в позицию *value*.

И в заключении, вот еще две функции, которые позволяют получать или устанавливать значение ползунка, зная только его имя и имя окна к которому слайдер привязан: 

```cpp
int cvGetTrackbarPos(
     const char*    trackbar_name
    ,const char*    window_name
);

void cvSetTrackbarPos(
     const char*    trackbar_name
    ,const char*    window_name
    ,int            pos
);
```

Вызывать данные функции можно из любого места программы.


### No Buttons

К сожалению, **HighGUI** не обеспечивает явную поддержку для кнопок. Таким образом, общая практика преодоления данной проблемы заключается в использовании ползунка только в двух позициях. Другой вариант решения проблемы представлен в *.../opencv/samples/c/* и заключается в использовании сочетании клавиш вместо кнопок (*floodfill* демо в исходниках OpenCV).

*Switches* (переключатель) это облегченный вариант слайдера, у которого только две позиции "on" (1) и "off" (0) (*count = 1*). Используя слайдер как кнопку, функция обратного вызова автоматически сбрасывает переключатели в 0 (пример 4-2) или же автоматически сбрасывает в 0 другие переключатели (эффект "радиокнопок").

Пример 4-2. Использование слайдера как переключателя

```cpp
// Значение переключателя (глобальная переменная)
// 
int g_switch_value = 0;

// Функция обратного вызова
// 
void switch_callback( int position ) {
    if( 0 == position ) {
        switch_off_function();
    } 
    else {
        switch_on_function();
    }
}

int main( int argc, char* argv[] ) {
    // Создание окна
    // 
    cvNamedWindow( "Demo Window", 1 );

    // Создание слайдера с привязкой к окну
    // "Demo Window"
    // 
    cvCreateTrackbar(
         "Switch"
        ,"Demo Window"
        ,&g_switch_value
        ,1
        ,switch_callback
    );

    // Ожидание нажатия кнопки Esc
    // 
    while( 1 ) {
        if( 27 == cvWaitKey( 15 ) ) {
            break;
        }
    }
}
```

