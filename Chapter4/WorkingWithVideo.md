## [П]|[РС]|(РП) Работа с видео

Есть несколько функций для работы с видео в OpenCV, наиболее используемыми из которых являются функция чтения и записи видео. Но обо всем по порядку.

*CvCapture* - структура, содержащая необходимую информацию для чтения кадров с камеры или из видеопотока. В зависимости от источника, необходимо использовать одну из ниже перечисленных функций:

```cpp
CvCapture* cvCreateFileCapture( const char* filename );
CvCapture* cvCreateCameraCapture( int index );
```

*cvCreateFileCapture()* принимает всего один аргумент - имя AVI или MPG файла. После вызова этой функции OpenCV открывает и подготавливает файл для чтения. Если открытие файла произошло успешно, то функция вернет указатель на структуру *CvCapture*.

Если по какой-то причине, файл не существует или не найден соответствующий кодек, функция вернет NULL. Тонкости работы кодеков сжатия выходят за пределы данной книги, но в целом, достаточно знать в каком случае какой кодек уместно применять и установлен ли он на компьютере. Например, необходимо прочитать файл закодированный с помощью DIVX или сжат с помощью MPG4 на компьютере с ОС Windows. Для корректной обработки должна быть установлена соответствующая библиотека, которая предоставит все необходимые ресурсы для декодирования видео. Крайне необходимо проверять возвращаемое значение на NULL, т.к. все компьютеры имеют разный набор ПО (например, может отсутствовать библиотека для декодирования видео). 

Функция *cvCreateCameraCapture()* принимает идентификатор, указывающий к какой камере необходимо получить доступ. Если камера одна, то идентификатор можно установить в 0. *index* - это сумма из порядкового номера и "домена". "Домен" указывает на тип камеры.

Таблица 4-3. Значения домена

| Константа | Значение |
| -- | -- |
| CV_CAP_ANY | 0 |
| CV_CAP_MIL | 100 |
| CV_CAP_VFW | 200 |
| CV_CAP_V4L | 200 |
| CV_CAP_V4L2 | 200 |
| CV_CAP_FIREWIRE | 300 |
| CV_CAP_IEEE1394 | 300 |
| CV_CAP_DC1394 | 300 |
| CV_CAP_CMU1394 | 300 |

Во время вызова *cvCreateCameraCapture* передается сумма индекса и "домена":

```cpp
CvCapture* capture = cvCreateCameraCapture( CV_CAP_FIREWIRE );
```

В данном примере происходит попытка открыть первую *FireWire* камеру, т.к. индекс равен 0. В большинстве случаев не обязательно указывать "домен", когда используется только одна камера; достаточно использовать *CV_CAP_ANY*. Если в функцию передать значение -1, то OpenCV выведет диалоговое окно для выбора нужной камеры.


### Чтение видео

```cpp
int cvGrabFrame( CvCapture* capture );
IplImage* cvRetrieveFrame( CvCapture* capture );
IplImage* cvQueryFrame( CvCapture* capture );
```

Имея верно сформированную структуру *CvCapture*, можно переходить к захвату кадров. Есть два варианта сделать это. Один из них заключается в использовании функции *cvGrabFrame()*, которая принимает указатель на *CvCapture* и возвращает 1, если захват был успешен, и 0 если нет. Функция *cvGrabFrame()* копирует изображение во внутренний, не доступный пользователю, буфер. Возникает вопрос зачем это нужно, захватить кадр и не иметь к нему доступ? Ответ прост - захваченный кадр не обрабатывается, тем самым давая выигрыш в скорости получения кадра.

После вызова *cvGrabFrame()* необходимо вызвать *cvRetrieveFrame()*. Эта функция выполняет все необходимые преобразования кадра (такие, как декомпрессия в кодеке) и возвращает указатель *IplImage*\* на другой внутренний буфер (но не стоит на него рассчитывать, т.к. при следующем вызове *cvGrabFrame()* он будет перезаписан). Если потребуется произвести собственную обработку кадра, то необходимо скопировать данный кадр. При этом указатель на структуру *CvCapture* не должен быть уничтожен до окончания работ с видео, иначе могут возникнуть непредвиденные проблемы с обработкой видео.

*cvQueryFrame()* - иной способ получения кадров из видеопотока. В сущности, это сочетание *cvGrabFrame()* и *cvRetrieveFrame()*; эта функция так же возвращает указатель на *IplImage*\*.

Следует отметить, что при чтении видеофайла кадры читаются один за другим при каждом вызове *cvGrabFrame()*, и потому не нужно увеличивать никаких счётчиков.

Освобождение памяти из-под структуры *CvCapture* производится с помощью функции *cvReleaseCapture()*. Как и многие другие функции OpenCV для освобождения памяти, *cvReleaseCapture()* принимает указатель на указатель *CvCapture*\*:

```cpp
void cvReleaseCapture( CvCapture** capture );
```

Есть еще множество других вещей, которые можно делать со структурой *CvCapture*. В частности, можно получить или установить различные свойства источника видео:

```cpp
double cvGetCaptureProperty(
     CvCapture* capture
    ,int        property_id
);
int cvSetCaptureProperty(
     CvCapture* capture
    ,int        property_id
    ,double     value
);
```

Функция *cvGetCaptureProperty()* принимает любой из идентификаторов, представленных в таблице 4-4: 

Таблица 4-4. Свойства *CvCapture*

| Свойство | Значение |
| -- | -- |
| CV_CAP_PROP_POS_MSEC | 0 |
| CV_CAP_PROP_POS_FRAME | 1 |
| CV_CAP_PROP_POS_AVI_RATIO | 2 |
| CV_CAP_PROP_FRAME_WIDTH | 3 |
| CV_CAP_PROP_FRAME_HEIGHT | 4 |
| CV_CAP_PROP_FPS | 5 |
| CV_CAP_PROP_FOURCC | 6 |
| CV_CAP_PROP_FRAME_COUNT | 7 |

*POS_MSEC* - текущая позиция в видео файле, в миллисекундах. *POS_FRAME* текущая позиция в файле, в кадрах. *POS_AVI_RATIO* - текущая позиция в файле, заданная числом между 0 и 1 (на самом деле очень полезная вещь при совместном использовании с ползунком для перемотки видео). *FRAME_WIDTH* и *FRAME_HEIGHT* - размер кадра. *FPS* - количество кадров в секунду; влияет на плавность воспроизводимого видео. *FOURCC* - четырехзначный код кодека. *FRAME_COUNT* - количество кадров в видеопотоке (ненадежное значение).

Для всех этих значений будет возвращено значение типа *double*, исключением является значение *FOURCC*. Для верной трактовки случая с *FOURCC*, необходимо произвести еще дополнительное преобразование (пример 4-3).

Пример 4-3. Распаковка четырехзначного кода

```cpp
double f = cvGetCaptureProperty(
     capture
    ,CV_CAP_PROP_FOURCC
);

char* fourcc = (char*) (&f);
```

Каждое из этих свойств можно не только получать, но и устанавливать при помощи функции *cvSetCaptureProperty()*. В действительности, не всегда свойства можно изменить. Например, некоторые 
кодеки могут не поддерживать функцию перемещения по видео. 


### Запись видео

Операция записи видео в какой-то степени схожа с операцией чтения видеофайла, но с несколькими дополнительными деталями.

```cpp
CvVideoWriter* cvCreateVideoWriter(
     const char*    filename
    ,int            fourcc
    ,double         fps
    ,CvSize         frame_size
    ,int            is_color = 1
);

int cvWriteFrame(
     CvVideoWriter*     writer
    ,const IplImage*    image
);

void cvReleaseVideoWriter(
     CvVideoWriter** writer
);
```

Для начала нужно создать устройство записи, используя структуру *CvVideoWriter*. Для создания этой структуры используется функция *cvCreateVideoWriter()*.

Помимо имени файла, необходимо указать кодек, скорость записи и размер кадра. Необязательно, но можно также указать цвет кадра: цветной или черно-белый (по умолчанию цветной).

Кодек задается при помощи четырехзначного кода. В функцию код передается в упакованном виде. Так как эта операция выполняется относительно часто, OpenCV предоставляет удобный макрос *CV_FOURCC(c0, c1, c2, c3)*.

После создания устройства записи необходимо вызвать функцию *cvWriteFrame()* с передачей в неё *CvVideoWriter*\* и *IplImage*\* изображения, которое подлежит записи. 

По завершению работы с видео, необходимо вызвать функцию *CvReleaseVideoWriter()* что бы закрыть устройство записи, а затем и файл, в которой производилась запись. Крайне важно не забывать выполнять данную операцию, иначе файл, в который производилась запись, будет поврежден.

