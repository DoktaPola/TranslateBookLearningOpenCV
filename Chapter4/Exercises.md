## [П]|[РС]|(РП) Упражнения

1. Эта глава завершает введение в основы OpenCV. Следующие упражнения, основанные на всех ранее полученных знаниях, помогут создать набор полезных утилит для дальнейшего использования их в изучении последующих глав. 
	
	a. Напишите программу, которая: (1) читает кадры из видеофайла, (2) конвертирует получаемые кадры в черно-белый формат и (3) выполняет поиск краев, используя функцию *cvCanny()*. Отобразить результат каждого шага в трех разных окнах.

	b. Отобразите все три этапа обработки на одном изображении.
	
	*Подсказка: создайте новое изображение с той же высотой и тройной шириной как у кадра. Скопируйте изображения в только что созданное изображение, либо с помощью указателей, либо, что более умно, с помощью создания трёх заголовков изображения, которые указывают на начало, на 1/3 и на 2/3 imageData изображения. Затем используйте cvCopy().*
	
c. Создайте соответствующие текстовые метки, описывающие обработку каждого изображения.

2. Напишите программу, которая считывает и отображает изображение. При щелчке мыши на изображении, отобразите значения трех каналов (синий, зеленый, красный) в месте щелчка в виде текста на изображении. 

	a. Используя программу из 1b, отобразить значения щелков мыши в виде текста на изображении в трех разных окнах. 

3. Напишите программу, которая считывает и отображает изображение.

	a. Реализуйте возможность рисования (щелчок левой клавиши, перемещение и отпускание клавиши мыши) прямоугольника на изображении при помощи мыши. Будьте осторожны, сохраните копию исходного изображения в памяти, чтобы не испортить его. При повторном рисовании ранее созданный прямоугольник удаляется, а новый рисуется на исходном изображении. 

	b. В отдельном окне нарисуйте график количества используемых значений синего, зеленого и красного каналов. Ось *x* разбить на 8 блоков, каждый блок должен иметь диапазон в 32 значения: 0-31, 32-63, ..., 223-255. По оси *y* количество найденных пикселей в данном диапазоне.

4. Напишите программу, которая читает, отображает и контролирует, при помощи слайдеров, видео. Первый слайдер контролирует позицию в видео с шагом перемещения 10; второй слайдер контролирует процесс включения и выключения воспроизведения видео. Дайте имена слайдерам соответствующим образом. 

5. Напишите упрощённый вариант paint-а.

	а. Напишите программу, которая создает изображение (белое полотно), устанавливает все значения в 0 и отображает результат на экране. Обеспечить возможность рисовать линии, круги, эллипсы и полигоны, используя левую клавишу мыши. Создайте функцию "ластик", которая будет вызываться при нажатии правой клавиши мыши. 

	b. Добавьте возможность "логики рисования" при помощи слайдера. Возможные варианты: *AND*, *OR* и *XOR*. Например, при использовании *AND*, рисование будет происходить только в тех местах полотна, где значение отлично от 0.

6. Напишите программу, которая создает изображение (белое полотно), устанавливает все значения в 0 и отображает результат на экране. В месте нажатия пользователем клавиши мыши обеспечить возможность в написании текста. По нажатию *Backspace* удалять введенные символы. По нажатию *Enter* текст должен становиться не редактируемым. 

7. Перспективные преобразования

	a. Напишите программу, которая считывает изображение и использует цифры 1-9 на клавиатуре для управления матрицей перспективного преобразования (функция *cvWarpPerspective()* из 6 главы). Нажатие любой клавиши с цифрой должно увеличивать соответствующую ячейку в матрице перспективного преобразования; в сочетании с *Shift* следует уменьшать соответствующую ячейку в матрице перспективного преобразования (останавливаться при достижении 0). Результат нажатия клавиши клавиатуры выводить в два окна: окно с исходным изображением и окно с преобразованным изображением.

	b. Добавьте функциональность изменения масштаба.

	c. Добавьте функциональность изменения угла.

8. Перейдите в директорию */samples/c/* и откройте файл *facedetector.c*. Нарисуйте изображение черепа (или найдите в интернете) и сохраните его на диск. Измените программу *facedetector* для загрузки изображения черепа. 

	a. Когда лицо будет найдено, будет выделено прямоугольником, нарисовать изображение черепа в прямоугольнике.
	
	*Подсказка: изменить размер изображения можно при помощи *cvConvertImage()* или *cvResize()*. Активизировать часть изображения (область ROI) и поместить туда изображение черепа при помощи функции *cvCopy()*.*
	
	b. Добавить ползунок из 10 значений в интервале от 0.0 до 1.0. Использовать этот ползунок для альфа смешивания черепа и исходного изображения (задействуйте функцию *cvAddWeighted()*).

9.  Стабилизация изображения. Перейдите в директорию */samples/c/* и откройте код *lkdemo* (код отслеживания движений или оптического потока). Создайте и отобразите видео в окне по размерам превышающее размеры кадра. (!)Немного по перемещайте камеру в течение непродолжительного отрезка времени, используя вектора оптического потока для отображения изображения в окне большего размера.(!) Это элементарная техника стабилизации изображения.
