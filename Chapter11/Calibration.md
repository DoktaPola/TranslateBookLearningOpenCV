## (П]|(РС)|(РП) Калибровка

Теперь, после получения некоторого представления о том, как описать внутренние свойства и искажения камеры математически, можно перейти к рассмотрению того, как использовать OpenCV для вычисления внутренних матриц и вектора искажений. (Онлайн руководство по использованию калибровки камеры можно найти на сайте [Jean-Yves Bouguet](http://www.vision.caltech.edu/bouguetj/calib_doc/))

OpenCV предоставляет несколько алгоритмов для вычисления этих внутренних параметров. Калибровка выполняется при помощи функции *cvCalibrateCamera2()*. В данной функции метод калибровки предоставленной камеры заключается в формировании известной структуры, содержащей множество индивидуальных и идентифицируемых точек. При рассмотрении данной структуры под разными углами можно в последующем вычислить (относительное) местоположение и ориентацию камеры во время каждого получаемого кадра, а также внутренние параметры камеры (рисунок 11-9, раздел "Шахматная доска"). Для получения набора представлений, необходимо поворачивать и смещать объект, поэтому вначале необходимо рассмотреть эти процессы более подробно.

### Матрица поворота и вектор смещения

Для каждого кадра, содержащего определенный объект, существует возможность описать позу данного объекта по отношению к системе координат камеры в условиях вращения и смещения, рисунок 11-7.

![Рисунок 11-7 не найден](Images/Pic_11_7.jpg)

Рисунок 11-7. Преобразование объекта в систему координат камеры: точка P объекта рассматривается как точка p на плоскости изображения; точка p связана с точкой P за счет применения матрицы вращения R и вектора смещения t к P

В общем, вращении в любом n-мерном измерении может быть описано как перемножение координат вектора квадратной матрицы соответствующего размера. В конечном счете, вращение эквивалентно введению новых расположений точи в другой системе координат. Поворот системы координат на угол θ эквивалентно вращению в противоположном направлении целевой точки вокруг исходной системы координат на тот же угол θ. Двумерное вращение можно представить как перемножение матриц показанных на рисунке 11-8. Трехмерное вращение можно разложить на двумерное вращение вокруг каждой оси при условии, что ось вращения остается неизменной. При вращении в последовательности (представленное описание вращения выполняет вращение сначала вокруг оси z, затем вокруг нового положения оси y и, наконец, вокруг нового положения оси x) вокруг x-, y- и z-осей на углы ψ, φ и θ соответственно, общую матрицу поворота R можно получить в результате перемножения трех матриц ![Формула 11-38 не найдена](Images/Frml_11_38.jpg), ![Формула 11-39 не найдена](Images/Frml_11_39.jpg) и ![Формула 11-40 не найдена](Images/Frml_11_40.jpg), где:

![Формула 11-41 не найдена](Images/Frml_11_41.jpg)

![Формула 11-42 не найдена](Images/Frml_11_42.jpg)

![Формула 11-43 не найдена](Images/Frml_11_43.jpg)

![Рисунок 11-8 не найден](Images/Pic_11_8.jpg)

Рисунок 11-8. Вращение точек на θ (в данном случае, вокруг оси Z) это тоже самое, что и противоположное вращение  оси координат на θ; за счет простой тригонометрии можно увидеть, как вращение меняет координаты точек

Общая матрица вращения R имеет свойство, что обратная ей матрица является транспонированной матрицей (повернутая назад); следовательно ![Формула 11-44 не найдена](Images/Frml_11_44.jpg), где *I* это единичная матрица (элементы по диагонали равны 1, а все остальные элементы равны 0).

*Вектор смещения* представляет собой переход от одной системы координат к другой, полученный в результате смещения в новое положение; другими словами, вектор сдвига – это просто смещение относительно первоначальной системы координат. Таким образом, при переходе от системы координат с центрированием на объекте к центрированию на камере, соответствующий вектор сдвига будет выглядеть следующим образом ![Формула 11-45 не найдена](Images/Frml_11_45.jpg). В результате (рисунок 11-7) точка в системе координат объекта с координатами ![Формула 11-46 не найдена](Images/Frml_11_46.jpg) имеет координаты ![Формула 11-47 не найдена](Images/Frml_11_47.jpg) в системе координат камеры:

![Формула 11-48 не найдена](Images/Frml_11_48.jpg)

Объединение данного уравнения с выше представленными исправлениями внутренних параметров камеры формируют базовую систему уравнений, которую необходимо передавать OpenCV для калибровки камеры.

 Как уже было сказано ранее, для описания трехмерного вращения достаточно указать 6 параметров: три параметра положения и три параметра углов вращения. Вдобавок к этому в OpenCV матрица встроенных параметров камеры имеет ещё четыре параметра (![Формула 11-7 не найдена](Images/Frml_11_7.jpg), ![Формула 11-9 не найдена](Images/Frml_11_9.jpg), ![Формула 11-2 не найдена](Images/Frml_11_2.jpg) и ![Формула 11-3 не найдена](Images/Frml_11_3.jpg)), что в общей сложности дает десять параметров, которые должны быть получены для каждого представления в отдельности (при этом внутренние параметры камеры остаются неизменными). В случае двумерного вращения задействуются восемь параметров. Шесть параметров для описания вращения и смещения между представлениями и два для матрицы внутренних параметров камеры. И, по крайней мере, в двух представлениях необходимо найти все геометрические параметры.

Далее будут более подробно рассмотрены эти параметры и накладываемые на них ограничения, но для начала необходимо уделить немного времени рассмотрению *калибровочного объекта*. Калибровочным объектом в OpenCV является плоская сетка с чередующимися черными и белыми квадратами, которую обычно называют «шахматной доской» (хотя не обязательно имеющая восемь квадратов или даже равное количество квадратов в каждом из направлений).

### Шахматная доска

В принципе, любой достаточно характерный объект может быть использован в качестве калибровочного объекта, однако, практичней всего использовать такой шаблон, как шахматная доска. В литературе некоторые методы колибровки полагаются на трехмерные объекты (например коробка накрытая ориентиром), однако, плоская модель шахматной доски гораздо легче в обращнии; трудно сделать (а так же хранить и распространять) точные калибровочные 3D объекты. В результате, OpenCV работает с несколькими представлениями плоского калибровочного объекта (шахматная доска), а не с одним специально сконструированным 3D объектом. В дальнейшем будет использован шаблон, состоящий из сменяющихся черных и белых квадратов (рисунок 11-9), который гарантирует, что нет никакого смещения к той или иной стороне измерения. Кроме того, результирующие углы сетки можно передать в функцию локализации субпикселей, обсуждаемую в главе 10.

![Рисунко 11-9 не найден](Images/Pic_11_9.jpg)

Рисунок 11-9. Изображения шахматной доски, получаемые в различных ориентациях (слева), предоставляют достаточное количество информации для понимания положения этих изображений в глобальной системе координат (относительно камеры), а также получения встроенных параметров камеры

Изображение шахматной доски (или изображение с человеком, держащего шахматную доску) можно использовать в функции OpenCV *cvFindChessboardCorners()* для поиска квадратов шахматной доски:

```cpp
int cvFindChessboardCorners(
	 const void* 		image
	,CvSize 			pattern_size
	,CvPoint2D32f* 		corners
	,int* 				corner_count 	= NULL
	,int 				flags 			= CV_CALIB_CB_ADAPTIVE_THRESH
);
```

На вход данной функции в качестве первого аргумента передается одно изображение шахматной доски. Это изображение должно быть 8-битным серого цвета (один канал). Второй аргмент *pattern_size* указывает какое количество квадратов в каждой строке и столбце доски. Иными словами это счетчик числа квадратов в *пределах* доски; таким образом, для стандартной игровой шахматной доски значение будет равно *CvSize(7, 7)*. (На практике, чаще всего бывает удобнее использовать ассиметричную шахматную доску четно-нечетного размера, например (5, 6). Ассиметричная доска имеет только одну ось симметрии, поэтому ориентация доски может быть определена однозначно). Следующий аргумент *corners* является указателем на массив, в который можно будет записать расположение квадратов. Этот массив должен инициализирован перед вызовом функции и, конечно же, должен быть достаточно большим для размещения всех квадратов доски (для стандартной игровой шахматной доски это значение равно 49). Элементы массива это положения квадратов в пиксельных координатах. Аргумент *corner_count* не обязателен; если *corner_count != NULL*, то это указатель на *integer* для указания числа квадратов, которые необходимо записать. Если функция успешно нашла все квадраты (на самом деле условие успешного выполнения немного строже: должны быть найдены не только все квадраты, но и они же должны быть упорядочены в строках и столбцах в соответствии с ожиданиями), то возвращаемое значение будет не нулевым числом. Если функция завершилась с ошибкой, то будет возвращен 0. Последний аргумент *flags* может быть использован для реализации одного или нескольких шагов фильтрации для улучшения процесса поиска квадратов. Флаги могут быть объединены при помощи логического *OR*.

*CV_CALIB_CB_ADAPTIVE_THRESH*

По умолчанию в функции используетс япервый порог на основе средней яркости, но если установлен этот флаг, то будет использован адаптивный порог

*CV_CALIB_CB_NORMALIZE_IMAGE*

За счет этого флага изображение нормализуется при помощи *cvEqualizeHist()* перед применением порога

*CV_CALIB_CB_FILTER_QUADS*

