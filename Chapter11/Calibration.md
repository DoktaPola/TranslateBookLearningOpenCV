## (П]|(РС)|(РП) Калибровка

!!! Заменить слово квадрат на угол или угловой !!!

Теперь, после получения некоторого представления о том, как описать внутренние свойства и искажения камеры математически, можно перейти к рассмотрению того, как использовать OpenCV для вычисления внутренних матриц и вектора искажений. (Онлайн руководство по использованию калибровки камеры можно найти на сайте [Jean-Yves Bouguet](http://www.vision.caltech.edu/bouguetj/calib_doc/))

OpenCV предоставляет несколько алгоритмов для вычисления этих внутренних параметров. Калибровка выполняется при помощи функции *cvCalibrateCamera2()*. В данной функции метод калибровки предоставленной камеры заключается в формировании известной структуры, содержащей множество индивидуальных и идентифицируемых точек. При рассмотрении данной структуры под разными углами можно в последующем вычислить (относительное) местоположение и ориентацию камеры во время каждого получаемого кадра, а также внутренние параметры камеры (рисунок 11-9, раздел "Шахматная доска"). Для получения набора представлений, необходимо поворачивать и смещать объект, поэтому вначале необходимо рассмотреть эти процессы более подробно.

### Матрица поворота и вектор смещения

Для каждого кадра, содержащего определенный объект, существует возможность описать позу данного объекта по отношению к системе координат камеры в условиях вращения и смещения, рисунок 11-7.

![Рисунок 11-7 не найден](Images/Pic_11_7.jpg)

Рисунок 11-7. Преобразование объекта в систему координат камеры: точка P объекта рассматривается как точка p на плоскости изображения; точка p связана с точкой P за счет применения матрицы вращения R и вектора смещения t к P

В общем, вращении в любом n-мерном измерении может быть описано как перемножение координат вектора квадратной матрицы соответствующего размера. В конечном счете, вращение эквивалентно введению новых расположений точи в другой системе координат. Поворот системы координат на угол θ эквивалентно вращению в противоположном направлении целевой точки вокруг исходной системы координат на тот же угол θ. Двумерное вращение можно представить как перемножение матриц показанных на рисунке 11-8. Трехмерное вращение можно разложить на двумерное вращение вокруг каждой оси при условии, что ось вращения остается неизменной. При вращении в последовательности (представленное описание вращения выполняет вращение сначала вокруг оси z, затем вокруг нового положения оси y и, наконец, вокруг нового положения оси x) вокруг x-, y- и z-осей на углы ψ, φ и θ соответственно, общую матрицу поворота R можно получить в результате перемножения трех матриц ![Формула 11-38 не найдена](Images/Frml_11_38.jpg), ![Формула 11-39 не найдена](Images/Frml_11_39.jpg) и ![Формула 11-40 не найдена](Images/Frml_11_40.jpg), где:

![Формула 11-41 не найдена](Images/Frml_11_41.jpg)

![Формула 11-42 не найдена](Images/Frml_11_42.jpg)

![Формула 11-43 не найдена](Images/Frml_11_43.jpg)

![Рисунок 11-8 не найден](Images/Pic_11_8.jpg)

Рисунок 11-8. Вращение точек на θ (в данном случае, вокруг оси Z) это тоже самое, что и противоположное вращение  оси координат на θ; за счет простой тригонометрии можно увидеть, как вращение меняет координаты точек

Общая матрица вращения R имеет свойство, что обратная ей матрица является транспонированной матрицей (повернутая назад); следовательно ![Формула 11-44 не найдена](Images/Frml_11_44.jpg), где *I* это единичная матрица (элементы по диагонали равны 1, а все остальные элементы равны 0).

*Вектор смещения* представляет собой переход от одной системы координат к другой, полученный в результате смещения в новое положение; другими словами, вектор сдвига – это просто смещение относительно первоначальной системы координат. Таким образом, при переходе от системы координат с центрированием на объекте к центрированию на камере, соответствующий вектор сдвига будет выглядеть следующим образом ![Формула 11-45 не найдена](Images/Frml_11_45.jpg). В результате (рисунок 11-7) точка в системе координат объекта с координатами ![Формула 11-46 не найдена](Images/Frml_11_46.jpg) имеет координаты ![Формула 11-47 не найдена](Images/Frml_11_47.jpg) в системе координат камеры:

![Формула 11-48 не найдена](Images/Frml_11_48.jpg)

Объединение данного уравнения с выше представленными исправлениями внутренних параметров камеры формируют базовую систему уравнений, которую необходимо передавать OpenCV для калибровки камеры.

 Как уже было сказано ранее, для описания трехмерного вращения достаточно указать 6 параметров: три параметра положения и три параметра углов вращения. Вдобавок к этому в OpenCV матрица встроенных параметров камеры имеет ещё четыре параметра (![Формула 11-7 не найдена](Images/Frml_11_7.jpg), ![Формула 11-9 не найдена](Images/Frml_11_9.jpg), ![Формула 11-2 не найдена](Images/Frml_11_2.jpg) и ![Формула 11-3 не найдена](Images/Frml_11_3.jpg)), что в общей сложности дает десять параметров, которые должны быть получены для каждого представления в отдельности (при этом внутренние параметры камеры остаются неизменными). В случае двумерного вращения задействуются восемь параметров. Шесть параметров для описания вращения и смещения между представлениями и два для матрицы внутренних параметров камеры. И, по крайней мере, в двух представлениях необходимо найти все геометрические параметры.

Далее будут более подробно рассмотрены эти параметры и накладываемые на них ограничения, но для начала необходимо уделить немного времени рассмотрению *калибровочного объекта*. Калибровочным объектом в OpenCV является плоская сетка с чередующимися черными и белыми квадратами, которую обычно называют «шахматной доской» (хотя не обязательно имеющая восемь квадратов или даже равное количество квадратов в каждом из направлений).

### Шахматная доска

В принципе, любой достаточно характерный объект может быть использован в качестве калибровочного объекта, однако, практичней всего использовать такой шаблон, как шахматная доска. В литературе некоторые методы колибровки полагаются на трехмерные объекты (например коробка накрытая ориентиром), однако, плоская модель шахматной доски гораздо легче в обращнии; трудно сделать (а так же хранить и распространять) точные калибровочные 3D объекты. В результате, OpenCV работает с несколькими представлениями плоского калибровочного объекта (шахматная доска), а не с одним специально сконструированным 3D объектом. В дальнейшем будет использован шаблон, состоящий из сменяющихся черных и белых квадратов (рисунок 11-9), который гарантирует, что нет никакого смещения к той или иной стороне измерения. Кроме того, результирующие углы сетки можно передать в функцию локализации субпикселей, обсуждаемую в главе 10.

![Рисунко 11-9 не найден](Images/Pic_11_9.jpg)

Рисунок 11-9. Изображения шахматной доски, получаемые в различных ориентациях (слева), предоставляют достаточное количество информации для понимания положения этих изображений в глобальной системе координат (относительно камеры), а также получения встроенных параметров камеры

Изображение шахматной доски (или изображение с человеком, держащего шахматную доску) можно использовать в функции OpenCV *cvFindChessboardCorners()* для поиска квадратов шахматной доски:

```cpp
int cvFindChessboardCorners(
	 const void* 		image
	,CvSize 			pattern_size
	,CvPoint2D32f* 		corners
	,int* 				corner_count 	= NULL
	,int 				flags 			= CV_CALIB_CB_ADAPTIVE_THRESH
);
```

На вход данной функции в качестве первого аргумента передается одно изображение шахматной доски. Это изображение должно быть 8-битным серого цвета (один канал). Второй аргмент *pattern_size* указывает какое количество квадратов в каждой строке и столбце доски. Иными словами это счетчик числа квадратов в *пределах* доски; таким образом, для стандартной игровой шахматной доски значение будет равно *CvSize(7, 7)*. (На практике, чаще всего бывает удобнее использовать ассиметричную шахматную доску четно-нечетного размера, например (5, 6). Ассиметричная доска имеет только одну ось симметрии, поэтому ориентация доски может быть определена однозначно). Следующий аргумент *corners* является указателем на массив, в который можно будет записать расположение квадратов. Этот массив должен инициализирован перед вызовом функции и, конечно же, должен быть достаточно большим для размещения всех квадратов доски (для стандартной игровой шахматной доски это значение равно 49). Элементы массива это положения квадратов в пиксельных координатах. Аргумент *corner_count* не обязателен; если *corner_count != NULL*, то это указатель на *integer* для указания числа квадратов, которые необходимо записать. Если функция успешно нашла все квадраты (на самом деле условие успешного выполнения немного строже: должны быть найдены не только все квадраты, но и они же должны быть упорядочены в строках и столбцах в соответствии с ожиданиями), то возвращаемое значение будет не нулевым числом. Если функция завершилась с ошибкой, то будет возвращен 0. Последний аргумент *flags* может быть использован для реализации одного или нескольких шагов фильтрации для улучшения процесса поиска квадратов. Флаги могут быть объединены при помощи логического *OR*.

*CV_CALIB_CB_ADAPTIVE_THRESH*

По умолчанию в функции применяется вначале пороговые преобразования на основе средней яркости, но если установлен этот флаг, то будут использованы адаптивные пороговые преобразования

*CV_CALIB_CB_NORMALIZE_IMAGE*

За счет этого флага изображение нормализуется при помощи *cvEqualizeHist()* перед применением пороговых преобразований

*CV_CALIB_CB_FILTER_QUADS*

После выполнения пороговых преобразований, алгоритм попытается найти четырехугольники как результат перспективного представления черных квадратов шахматной доски. Это приближенный результат, т.к. предполагается, что ребра четырехугольника прямые, но это не совсем верно, потому что имеют место радиальные искажения. Если это флаг установлен, то к четырехугольникам применяются множество дополнительных ограничений для отброса ложных четырехугольников.

**Субпиксельные углы**

Квадраты. возвращаемые *cvFindChessboardCorners()* являются приблизительными. На практике это означает, что положения точны только в пределах устройства обработки изображения, т.е. с точностью до пикселя. Функция разделения должны быть использованы для вычисления точного расположения квадратов (после получения приблизительного положения и исходного изображения) с точностью до субпикселя. Это функция *cvFindCornerSubPix()*, которая уже была рассмотрена в главе 10. Использование данной функции в данном контексте не должно вызывать удивления, т.к. углы шахматной доски это всего навсего частный случай более общего случая углов Harris; просто углы шахматной доски проще найти и отследить. Пренебрежение субписельным уточнением может привести в существенным ошибкам в калибровке.

**Отрисовка углов шахматной доски**

В частности, при отладке, зачастую желательно нарисовать найденные углы шахматной доски на изображение (обычно на том, по которому производился поиск); таким образом, можно сравнить прогнозируемые и наблюдаемые углы. Для выполнения данной задачи OpenCV предоставляет удобную функцию *cvDrawChessboardCorners()*, которая соответственно и рисует углы, найденные *cvFindChessboardCorners()* на предоставленном изображении. Если в результате не все углы будут найдены, то имеющиеся углы будут нарисованы ввиде маленьких красных кругов. Если найдены все углы, то они будут окрашены в разные цвета (на каждую строку по одному цвету) и соединены линиями, представляющие порядок определения углов.

```cpp
void cvDrawChessboardCorners(
	 CvArr* 		image
	,CvSize 		pattern_size
	,CvPoint2D32f* 	corners
	,int 			count
	,int 			pattern_was_found
);
```

Первый аргумент *cvDrawChessboardCorners()* - это изображение, на которое будут наноситься углы. Т.к. углы будут представлены в виде цветных кругов , то это должно быть 8-битное цветное изображение и, в большинстве случаев, это будет копия исходного изображения, которое передавалось в *cvFindChessboardCorners()* (при этом необходимо предварительно выполнить преобразование в трехканальное изображение). Следующие два аргумента *pattern_size* и *corners* имеют точно такой же смысл, как и соответствующие аргументы функции *cvFindChessboardCorners()*. Аргумент *count* это целое число и равно числу углов. Аргумент *pattern_was_found* указывает на успех в поиске углов и может быть установлен при помощи *cvFindChessboardCorners()*. На рисунке 11-10 представлен результат применения *cvDrawChessboardCorners()* к изображению шахматной доски.

![Рисунок 11-10 не найден](Images/Pic_11_10.jpg)

Рисунок 11-10. Результат применения *cvDrawChessboardCorners()*: после того, как углы были найдены при помощи *cvFindChessboardCorners()*, можно нарисовать эти углы (мелкие круги по углам) и порядок определения этих углов (показан линиями между углами)

Теперь можно перейти к рассмотрению плоского объекта. Точки на плоскости подвергаются перспектиному преобразованию после прохождения через отверстие камеры обскуры или через объектив. Параметры данного преобразования содержаться в матрице гомографии размера 3x3, которая в следующем разделе будет рассмотрена более подробно.

### Гомография

В компьютерном зрении *плоская гомография* определяется как проективное отображение из одной плоскости в другую. Таким образом, отображение точек на двумерную плоскую поверхность фотоприёмника камеры является примером плоской гомографии. Данный пример можно показать в виде перемножения матриц при условии, что будут использованы однородные координаты для отображения точек Q и q на фотоприёмнике. Если определить:

![Формула 11- не найдена](Images/Frml_11_.jpg)

![Формула 11- не найдена](Images/Frml_11_.jpg)

тогда действие гомографии можно выразить следующим образом:

![Формула 11- не найдена](Images/Frml_11_.jpg)

Был введен параметр s как произвольный масштабный коэффициент (предназначенный для того, чтобы явно показать, что гомография определяется только этим коэффициентом). Условно этот коэффициент вынесен из H и при дальнейшем обсуждении весь рассматриваемый материал будет придерживаться этого правила.

