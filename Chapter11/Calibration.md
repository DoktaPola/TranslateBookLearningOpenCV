## (П]|(РС)|(РП) Калибровка

!!! Заменить слово квадрат на угол или угловой !!!

Теперь, после получения некоторого представления о том, как описать внутренние свойства и искажения камеры математически, можно перейти к рассмотрению того, как использовать OpenCV для вычисления внутренних матриц и вектора искажений. (Онлайн руководство по использованию калибровки камеры можно найти на сайте [Jean-Yves Bouguet](http://www.vision.caltech.edu/bouguetj/calib_doc/))

OpenCV предоставляет несколько алгоритмов для вычисления этих внутренних параметров. Калибровка выполняется при помощи функции *cvCalibrateCamera2()*. В данной функции метод калибровки предоставленной камеры заключается в формировании известной структуры, содержащей множество индивидуальных и идентифицируемых точек. При рассмотрении данной структуры под разными углами можно в последующем вычислить (относительное) местоположение и ориентацию камеры во время каждого получаемого кадра, а также внутренние параметры камеры (рисунок 11-9, раздел "Шахматная доска"). Для получения набора представлений, необходимо поворачивать и смещать объект, поэтому вначале необходимо рассмотреть эти процессы более подробно.

### Матрица поворота и вектор смещения

Для каждого кадра, содержащего определенный объект, существует возможность описать позу данного объекта по отношению к системе координат камеры в условиях вращения и смещения, рисунок 11-7.

![Рисунок 11-7 не найден](Images/Pic_11_7.jpg)

Рисунок 11-7. Преобразование объекта в систему координат камеры: точка P объекта рассматривается как точка p на плоскости изображения; точка p связана с точкой P за счет применения матрицы вращения R и вектора смещения t к P

В общем, вращении в любом n-мерном измерении может быть описано как перемножение координат вектора квадратной матрицы соответствующего размера. В конечном счете, вращение эквивалентно введению новых расположений точи в другой системе координат. Поворот системы координат на угол θ эквивалентно вращению в противоположном направлении целевой точки вокруг исходной системы координат на тот же угол θ. Двумерное вращение можно представить как перемножение матриц показанных на рисунке 11-8. Трехмерное вращение можно разложить на двумерное вращение вокруг каждой оси при условии, что ось вращения остается неизменной. При вращении в последовательности (представленное описание вращения выполняет вращение сначала вокруг оси z, затем вокруг нового положения оси y и, наконец, вокруг нового положения оси x) вокруг x-, y- и z-осей на углы ψ, φ и θ соответственно, общую матрицу поворота R можно получить в результате перемножения трех матриц ![Формула 11-38 не найдена](Images/Frml_11_38.jpg), ![Формула 11-39 не найдена](Images/Frml_11_39.jpg) и ![Формула 11-40 не найдена](Images/Frml_11_40.jpg), где:

![Формула 11-41 не найдена](Images/Frml_11_41.jpg)

![Формула 11-42 не найдена](Images/Frml_11_42.jpg)

![Формула 11-43 не найдена](Images/Frml_11_43.jpg)

![Рисунок 11-8 не найден](Images/Pic_11_8.jpg)

Рисунок 11-8. Вращение точек на θ (в данном случае, вокруг оси Z) это тоже самое, что и противоположное вращение  оси координат на θ; за счет простой тригонометрии можно увидеть, как вращение меняет координаты точек

Общая матрица вращения R имеет свойство, что обратная ей матрица является транспонированной матрицей (повернутая назад); следовательно ![Формула 11-44 не найдена](Images/Frml_11_44.jpg), где *I* это единичная матрица (элементы по диагонали равны 1, а все остальные элементы равны 0).

*Вектор смещения* представляет собой переход от одной системы координат к другой, полученный в результате смещения в новое положение; другими словами, вектор сдвига – это просто смещение относительно первоначальной системы координат. Таким образом, при переходе от системы координат с центрированием на объекте к центрированию на камере, соответствующий вектор сдвига будет выглядеть следующим образом ![Формула 11-45 не найдена](Images/Frml_11_45.jpg). В результате (рисунок 11-7) точка в системе координат объекта с координатами ![Формула 11-46 не найдена](Images/Frml_11_46.jpg) имеет координаты ![Формула 11-47 не найдена](Images/Frml_11_47.jpg) в системе координат камеры:

![Формула 11-48 не найдена](Images/Frml_11_48.jpg)

Объединение данного уравнения с выше представленными исправлениями внутренних параметров камеры формируют базовую систему уравнений, которую необходимо передавать OpenCV для калибровки камеры.

 Как уже было сказано ранее, для описания трехмерного вращения достаточно указать 6 параметров: три параметра положения и три параметра углов вращения. Вдобавок к этому в OpenCV матрица встроенных параметров камеры имеет ещё четыре параметра (![Формула 11-7 не найдена](Images/Frml_11_7.jpg), ![Формула 11-9 не найдена](Images/Frml_11_9.jpg), ![Формула 11-2 не найдена](Images/Frml_11_2.jpg) и ![Формула 11-3 не найдена](Images/Frml_11_3.jpg)), что в общей сложности дает десять параметров, которые должны быть получены для каждого представления в отдельности (при этом внутренние параметры камеры остаются неизменными). В случае двумерного вращения задействуются восемь параметров. Шесть параметров для описания вращения и смещения между представлениями и два для матрицы внутренних параметров камеры. И, по крайней мере, в двух представлениях необходимо найти все геометрические параметры.

Далее будут более подробно рассмотрены эти параметры и накладываемые на них ограничения, но для начала необходимо уделить немного времени рассмотрению *калибровочного объекта*. Калибровочным объектом в OpenCV является плоская сетка с чередующимися черными и белыми квадратами, которую обычно называют «шахматной доской» (хотя не обязательно имеющая восемь квадратов или даже равное количество квадратов в каждом из направлений).

### Шахматная доска

В принципе, любой достаточно характерный объект может быть использован в качестве калибровочного объекта, однако, практичней всего использовать такой шаблон, как шахматная доска. В литературе некоторые методы колибровки полагаются на трехмерные объекты (например коробка накрытая ориентиром), однако, плоская модель шахматной доски гораздо легче в обращнии; трудно сделать (а так же хранить и распространять) точные калибровочные 3D объекты. В результате, OpenCV работает с несколькими представлениями плоского калибровочного объекта (шахматная доска), а не с одним специально сконструированным 3D объектом. В дальнейшем будет использован шаблон, состоящий из сменяющихся черных и белых квадратов (рисунок 11-9), который гарантирует, что нет никакого смещения к той или иной стороне измерения. Кроме того, результирующие углы сетки можно передать в функцию локализации субпикселей, обсуждаемую в главе 10.

![Рисунок 11-9 не найден](Images/Pic_11_9.jpg)

Рисунок 11-9. Изображения шахматной доски, получаемые в различных ориентациях (слева), предоставляют достаточное количество информации для понимания положения этих изображений в глобальной системе координат (относительно камеры), а также получения встроенных параметров камеры

Изображение шахматной доски (или изображение с человеком, держащего шахматную доску) можно использовать в функции OpenCV *cvFindChessboardCorners()* для поиска квадратов шахматной доски:

```cpp
int cvFindChessboardCorners(
	 const void* 		image
	,CvSize 			pattern_size
	,CvPoint2D32f* 		corners
	,int* 				corner_count 	= NULL
	,int 				flags 			= CV_CALIB_CB_ADAPTIVE_THRESH
);
```

На вход данной функции в качестве первого аргумента передается одно изображение шахматной доски. Это изображение должно быть 8-битным серого цвета (один канал). Второй аргмент *pattern_size* указывает какое количество квадратов в каждой строке и столбце доски. Иными словами это счетчик числа квадратов в *пределах* доски; таким образом, для стандартной игровой шахматной доски значение будет равно *CvSize(7, 7)*. (На практике, чаще всего бывает удобнее использовать ассиметричную шахматную доску четно-нечетного размера, например (5, 6). Ассиметричная доска имеет только одну ось симметрии, поэтому ориентация доски может быть определена однозначно). Следующий аргумент *corners* является указателем на массив, в который можно будет записать расположение квадратов. Этот массив должен инициализирован перед вызовом функции и, конечно же, должен быть достаточно большим для размещения всех квадратов доски (для стандартной игровой шахматной доски это значение равно 49). Элементы массива это положения квадратов в пиксельных координатах. Аргумент *corner_count* не обязателен; если *corner_count != NULL*, то это указатель на *integer* для указания числа квадратов, которые необходимо записать. Если функция успешно нашла все квадраты (на самом деле условие успешного выполнения немного строже: должны быть найдены не только все квадраты, но и они же должны быть упорядочены в строках и столбцах в соответствии с ожиданиями), то возвращаемое значение будет не нулевым числом. Если функция завершилась с ошибкой, то будет возвращен 0. Последний аргумент *flags* может быть использован для реализации одного или нескольких шагов фильтрации для улучшения процесса поиска квадратов. Флаги могут быть объединены при помощи логического *OR*.

*CV_CALIB_CB_ADAPTIVE_THRESH*

По умолчанию в функции применяется вначале пороговые преобразования на основе средней яркости, но если установлен этот флаг, то будут использованы адаптивные пороговые преобразования

*CV_CALIB_CB_NORMALIZE_IMAGE*

За счет этого флага изображение нормализуется при помощи *cvEqualizeHist()* перед применением пороговых преобразований

*CV_CALIB_CB_FILTER_QUADS*

После выполнения пороговых преобразований, алгоритм попытается найти четырехугольники как результат перспективного представления черных квадратов шахматной доски. Это приближенный результат, т.к. предполагается, что ребра четырехугольника прямые, но это не совсем верно, потому что имеют место радиальные искажения. Если это флаг установлен, то к четырехугольникам применяются множество дополнительных ограничений для отброса ложных четырехугольников.

**Субпиксельные углы**

Квадраты. возвращаемые *cvFindChessboardCorners()* являются приблизительными. На практике это означает, что положения точны только в пределах устройства обработки изображения, т.е. с точностью до пикселя. Функция разделения должны быть использованы для вычисления точного расположения квадратов (после получения приблизительного положения и исходного изображения) с точностью до субпикселя. Это функция *cvFindCornerSubPix()*, которая уже была рассмотрена в главе 10. Использование данной функции в данном контексте не должно вызывать удивления, т.к. углы шахматной доски это всего навсего частный случай более общего случая углов Harris; просто углы шахматной доски проще найти и отследить. Пренебрежение субписельным уточнением может привести в существенным ошибкам в калибровке.

**Отрисовка углов шахматной доски**

В частности, при отладке, зачастую желательно нарисовать найденные углы шахматной доски на изображение (обычно на том, по которому производился поиск); таким образом, можно сравнить прогнозируемые и наблюдаемые углы. Для выполнения данной задачи OpenCV предоставляет удобную функцию *cvDrawChessboardCorners()*, которая соответственно и рисует углы, найденные *cvFindChessboardCorners()* на предоставленном изображении. Если в результате не все углы будут найдены, то имеющиеся углы будут нарисованы ввиде маленьких красных кругов. Если найдены все углы, то они будут окрашены в разные цвета (на каждую строку по одному цвету) и соединены линиями, представляющие порядок определения углов.

```cpp
void cvDrawChessboardCorners(
	 CvArr* 		image
	,CvSize 		pattern_size
	,CvPoint2D32f* 	corners
	,int 			count
	,int 			pattern_was_found
);
```

Первый аргумент *cvDrawChessboardCorners()* - это изображение, на которое будут наноситься углы. Т.к. углы будут представлены в виде цветных кругов , то это должно быть 8-битное цветное изображение и, в большинстве случаев, это будет копия исходного изображения, которое передавалось в *cvFindChessboardCorners()* (при этом необходимо предварительно выполнить преобразование в трехканальное изображение). Следующие два аргумента *pattern_size* и *corners* имеют точно такой же смысл, как и соответствующие аргументы функции *cvFindChessboardCorners()*. Аргумент *count* это целое число и равно числу углов. Аргумент *pattern_was_found* указывает на успех в поиске углов и может быть установлен при помощи *cvFindChessboardCorners()*. На рисунке 11-10 представлен результат применения *cvDrawChessboardCorners()* к изображению шахматной доски.

![Рисунок 11-10 не найден](Images/Pic_11_10.jpg)

Рисунок 11-10. Результат применения *cvDrawChessboardCorners()*: после того, как углы были найдены при помощи *cvFindChessboardCorners()*, можно нарисовать эти углы (мелкие круги по углам) и порядок определения этих углов (показан линиями между углами)

Теперь можно перейти к рассмотрению плоского объекта. Точки на плоскости подвергаются перспектиному преобразованию после прохождения через отверстие камеры обскуры или через объектив. Параметры данного преобразования содержаться в матрице гомографии размера 3x3, которая в следующем разделе будет рассмотрена более подробно.

### Гомография

В компьютерном зрении *плоская гомография* определяется как проективное отображение из одной плоскости в другую. Таким образом, отображение точек на двумерную плоскую поверхность фотоприёмника камеры является примером плоской гомографии. Данный пример можно показать в виде перемножения матриц при условии, что будут использованы однородные координаты для отображения точек Q и q на фотоприёмнике. Если определить:

![Формула 11- не найдена](Images/Frml_11_.jpg)

![Формула 11- не найдена](Images/Frml_11_.jpg)

тогда действие гомографии можно выразить следующим образом:

![Формула 11- не найдена](Images/Frml_11_.jpg)

Был введен параметр s как произвольный масштабный коэффициент (предназначенный для того, чтобы явно показать, что гомография определяется только этим коэффициентом). Условно этот коэффициент вынесен из H и в дальнейшем при рассмотрении материала данное правило будет выполняться.

За счет небольшого применения геометрии и матричной алгебры можно найти решение для этой матрицы преобразования. Наиболее важным моментом является то, что H состоит из двух частей: материальных преобразований, которые по существу определяют положение объекта на рассматриваемой плоскости; и проекции, которая выводит матрицу встроенных параметров камеры (рисунок 11-11).

![Рисунок 11-11 не найден](Images/Pic_11_11.jpg)

Рисунок 11-11. Представление плоского объекта построенное гомографией: отображение - от плоскости объекта до плоскости изображения - одновременно охватывает относительное расположение этих двух плоскостей, а также матрицу проекции камеры

По части материальных преобразований - это суммарное действие некоторого вращения *R* и некоторого сдвига *t*, которые относятся к плоскости на которой рассматривается плоскость изображения. Т.к. используются однородные координаты, то можно выполнить объединение в пределах одной матрицы следующим образом (*W* - это матрица 3x4, первые три колонки которой включают девять элементов *R*, а последняя колонка содержит три компонента векотра *t*):

![Формула 11- не найдена](Images/Frml_11_.jpg)

И в заключении перемножив матрицу *M* действий камеры (выраженную в проекционных координатах) и ![Формула 11- не найдена](Images/Frml_11_.jpg), получим следующее:

![Формула 11- не найдена](Images/Frml_11_.jpg)

Казалось бы, что все это значит. Тем не менее, оказывается, что на практике интерес вызывает не координата ![Формула 11- не найдена](Images/Frml_11_.jpg), которая определена для всех пространств, а координата ![Формула 11- не найдена](Images/Frml_11_.jpg), которая определена только для рассматриваемой плоскости. Это возможно только при небольшом упрощении.

Без ограничения общности, необходимо выбрать определенную плоскость объекта так, что Z = 0. Это необходимо, т.к. при разбиении матрицы вращения на три 3x1 столбца (т.е. ![Формула 11- не найдена](Images/Frml_11_.jpg)), то один из этих столбцов не потребуется. В частности:

![Формула 11- не найдена](Images/Frml_11_.jpg)

Матрицe гомографии H, которая отображает точки объекта на плоскости фотоприёмника, можно описать выражением ![Формула 11- не найдена](Images/Frml_11_.jpg), тогда: 

![Формула 11- не найдена](Images/Frml_11_.jpg)

При этом стоит отметить тот факт, что теперь матрица *H* имеет размерность 3x3.

OpenCV использует предыдущее уравнение для расчета матрицы гомографии. Библиотека использует несколько изображений одного объекта для вычисления преобразований и вращений для каждого представления, а также встроенных парметров камеры (которые одинаковы для всех представлений). Как уже была сказано ранее, вращение описывается тремя углами, а перемещение тремя смещениями; соответственно имеется шесть неизвестных для каждого вида. Это нормально, т.к. известно, что плоский объект (например, шахматная доска) дает восемь уравнений - т.е. отображение квадрата в четырехугольник можно описать четырьмя *(x, y)* точками. Каждый новый кадр дает восемь уравнений за счет шести новых внешних неизвестных, так что при наличии достаточного количества изображений имеется возможность вычислить любое количество собственных неизвестных (более подробно об этом чуть позже).

Матрица гомографии H связывает положения точек плоскости исходного изображения с точками плоскости конечного изображения (как правило, плоскости фотоприёмника) следующими уравнениями:

![Формула 11- не найдена](Images/Frml_11_.jpg)

![Формула 11- не найдена](Images/Frml_11_.jpg)

Стоит обратить внимание на тот факт, что существует возможность вычислить H ничего не зная о встроенной параметрах камеры. На самом деле, вычисление множества гомографий из нескольких представлений - это метод, который использует OpenCV для вычисления внутренних параметров камеры.

OpenCV предоставляет удобную функцию *cvFindHomography()*, которая принимает список соответствий и возвращает матрицу гомографии, которая наилучшим образом описывает эти соответствия. Необходимо как минимум четыре точки, чтобы найти H, однако, всегда имеется возможность предоставить гораздо большее количество точек (при условии рассмотрения шахматной доски размера большего чем 3x3). использование большего количества точек гораздо выгоднее, т.к. всегда имеется шум и иные несоответствия, влияние которых необходимо сводить к минимуму.

```cpp
void cvFindHomography(
	 const CvMat* 	src_points
	,const CvMat* 	dst_points
	,CvMat* 		homography
);
```

Входные массивы *src_points* и *dst_points* могут быть матрицами Nx2 или Nx3. В первом случае координаты пикселей, во втором однородные координаты. Последний аргумент *homography* это матрица 3x3, заполненная при помощи данной функции таким образом, чтобы минимизировать ошибку обратной проекции. Т.к. матрица гомографии имеет только восемь сободных параметров, то лучше всего нормализовать ![Формула 11- не найдена](Images/Frml_11_.jpg) = 1. Масштабирование гомографии может быть применено к девятому параметру гомографии, но обычно масштабирование выполняется за счет умножения всей матрицы гомографии на коэффициент масштабирования.

### Калибровка камеры

Теперь всё готово для калибровки камеры и получения встроенных параметров и параметров искажений. Данный раздел будет посвящен вычислению этих параметров за счет использования *cvCalibrateCamera2()* а также тому, как использовать эти модели для исправления искажений на изображениях, получаемых с калибровочной камеры. Вначале будет немного более подробно рассказано о том, как много представлений шахматной доски необходимо предоставить для вычисления внутренних параметров камеры и искажений. Затем будет высокоуровневый обзор того, как OpenCV на самом деле решает данную систему уравнений. И в заключении будет предоставлен код, который позволяет с лёгкостью справиться с данной задачей.

**Сколько углов шахматной доски для скольких параметров?**

Теперь необходимо рассмотреть ранее представленные неизвестные. Т.е. параметры которые необходимо найти путем калибровки. В случае OpenCV имеется четыре внутренних параметра камеры (![Формула 11-7 не найдена](Images/Frml_11_7.jpg), ![Формула 11-9 не найдена](Images/Frml_11_9.jpg), ![Формула 11-2 не найдена](Images/Frml_11_2.jpg), ![Формула 11-3 не найдена](Images/Frml_11_3.jpg)) и пять параметров искажений: три для радиальных (![Формула 11-27 не найдена](Images/Frml_11_27.jpg), ![Формула 11-28 не найдена](Images/Frml_11_28.jpg), ![Формула 11-29 не найдена](Images/Frml_11_29.jpg)) и два для тангенциальных (![Формула 11-34 не найдена](Images/Frml_11_34.jpg), ![Формула 11-35 не найдена](Images/Frml_11_35.jpg)). Внутренние параметры камеры напрямую связаны с трехмерной геометрией (и следовательно с внешними параметрами) шахматной доски в пространстве; параметры искажений связаны с двухмерной геометрией набора искаженных точек, в результате получаем ограничение на эти два класса параметров отдельно. Три угловые точки известной модели дают шесть наборов информации – в принципе, это все, что необходимо для вычисления пяти параметров искажения (хотя на практике используется гораздо большее количество углов). Таким образом, одного представления шахматной доски вполне достаточно для вычисления параметров искажения. Это же представление шахматной доски можно использовать для вычисления внутренних параметров, которые вычисляются после получения внешних параметров. В случае с *внешними* параметрами необходимо знать положение шахматной доски. Для этого требуется три параметра вращения (ψ, ϕ, θ) и три параметра перемещения (![Формула 11- не найдена](Images/Frml_11_.jpg), ![Формула 11- не найдена](Images/Frml_11_.jpg), ![Формула 11- не найдена](Images/Frml_11_.jpg)), в общей сложности шесть за представление шахматной доски, т.к. в каждом изображении шахматной доски присутствуют перемещения. Итого, четыре внутренних и шесть внешних параметра дают десять параметров, которые необходимо вычислять для каждого представления.

Теперь пусть имеется N углов и K изображений шахматной доски (в различных позициях). Как много представлений и углов необходимо иметь для преодоления ограничений для всех ранее представленных параметров?

* K изображений шахматной доски обеспечивает 2NK ограничений (коэффициент 2 используется в связи с тем, что каждая точка изображения имеет две координаты x и y)

* Не принимая во внимание параметры искажения, имеется 4 внутренних параметра и 6K внешних параметра (т.к. необходимо найти 6 параметров положения шахматной доски для каждого представления K)

* Для решения также необходимо, чтобы 2NK ≥ 6K + 4 (или, что эквивалентно (N – 3) K ≥ 2)

Может показаться, что для N = 5 необходимо только K = 1 изображений. Однако это не так, K (количество представлений) должно быть больше 1. Причина, по которой K > 1 заключается в том, что используемая для калибровки шахматная доска должна соответствовать матрице гомографии для каждого K представления. Как уже было сказано ранее гомография может дать не более восьми параметров от четырех пар (x, y). Это всё из-за того, что необходимо иметь лишь четыре точки для выражения всего того, что может дать плоское перспективное представление: растянуть квадрат в четырех различных направлениях, превратив его тем самым в абсолютно любой четырехугольник (перспективные преобразования, глава 6). Таким образом, независимо от количества найденных углов на плоскости, ценными являются только четыре из них. Согласно уравнению одного представления шахматной доски, предоставляющее только четыре информативных угла или (4 - 3)K > 1, получается, что K > 1. Это означает, что два представления шахматной доски 3x3 (считая только внутренние углы) являются минимальными для решения проблемы калибровки. Принимая во внимание шум и вычислительную устойчивость, как правило, необходимо собирать больше изображений шахматной доски большего размера. На практике для получения наилучшего результата необходимо как минимум десять изображений 7x8 или большего размера шахматной доски (и это при условии, что будет предоставлен "богатый" набор представлений шахматной доски).

**Что под капотом?**

